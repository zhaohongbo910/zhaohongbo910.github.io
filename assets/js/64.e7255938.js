(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{663:function(t,s,a){"use strict";a.r(s);var e=a(2),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_2-在哪个生命周期做优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-在哪个生命周期做优化"}},[t._v("#")]),t._v(" 2.在哪个生命周期做优化？")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。")])]),t._v(" "),a("h2",{attrs:{id:"_3-react怎么从虚拟dom中拿出真实dom-ref"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-react怎么从虚拟dom中拿出真实dom-ref"}},[t._v("#")]),t._v(" 3.react怎么从虚拟dom中拿出真实dom?(ref）")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：")])]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CustomForm")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("extends")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Component")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("handleSubmit")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Input Value: "')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("render")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("form onSubmit"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("handleSubmit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("input\n                type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'text'")]),t._v("\n                ref"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("input")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("input "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" input"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n                "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("button type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'submit'")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("Submit"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("button"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v("form"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br"),a("span",{staticClass:"line-number"},[t._v("9")]),a("br"),a("span",{staticClass:"line-number"},[t._v("10")]),a("br"),a("span",{staticClass:"line-number"},[t._v("11")]),a("br"),a("span",{staticClass:"line-number"},[t._v("12")]),a("br"),a("span",{staticClass:"line-number"},[t._v("13")]),a("br"),a("span",{staticClass:"line-number"},[t._v("14")]),a("br"),a("span",{staticClass:"line-number"},[t._v("15")]),a("br")])]),a("h2",{attrs:{id:"_4-react的diff算法是怎么完成的-基础原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-react的diff算法是怎么完成的-基础原理"}},[t._v("#")]),t._v(" 4.react的diff算法是怎么完成的？(基础原理）")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("React采用虚拟DOM技术实现对真实DOM的映射，即React Diff算法的差异查找实质是对两个JavaScript对象的差异查找；\n基于三个策略：")]),t._v(" "),a("ul",[a("li",[t._v("Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（tree diff）")]),t._v(" "),a("li",[t._v("拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结（component diff）")]),t._v(" "),a("li",[t._v("对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。（element diff）")])])]),t._v(" "),a("p",[a("strong",[t._v("tree diff")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。\n既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React只会对相同层级的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。")])]),t._v(" "),a("ul",[a("li",[t._v("把树形结构按照层级分解，只比较同级元素。")]),t._v(" "),a("li",[t._v("给列表结构的每个单元添加唯一的 key 属性，方便比较。")]),t._v(" "),a("li",[t._v("React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）")]),t._v(" "),a("li",[t._v("合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.")]),t._v(" "),a("li",[t._v("选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。")])]),t._v(" "),a("h2",{attrs:{id:"_5-react中的props和state的用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-react中的props和state的用法"}},[t._v("#")]),t._v(" 5.React中的props和state的用法")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("1、props和state之间是紧密相关的。父组件的state传入转变子组件的就会变成props\n2、state 是一个组件自身的状态集合，一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。利用"),a("code",[t._v("this.setState({})")]),t._v(" 进行state的更新操作\n3、props 一般用于父组件向子组件通信，在组件之间通信使用。")])]),t._v(" "),a("h2",{attrs:{id:"_6-redux的流程中间件-react-thunk-redux-promise-redux-saga-redux-logger-dvtools的理解-用法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-redux的流程中间件-react-thunk-redux-promise-redux-saga-redux-logger-dvtools的理解-用法"}},[t._v("#")]),t._v(" 6.Redux的流程中间件（react-thunk,redux-promise,redux-saga,redux-logger   dvtools的理解，用法）")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("😊 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。")])]),t._v(" "),a("p",[a("strong",[t._v("redux-thunks")]),t._v(":处理异步的中间件 redux-thunk 中间件的功能也很简单。首先检查参数 action 的类型，如果是函数的话，就执行这个 action 函数，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action 。react-thunk 比较适合于简单的API请求的场景，其store下的actions只是普通的actionCreator，真正异步操作放在API里  "),a("strong",[t._v("api 异步操作 => action => reducer")])]),t._v(" "),a("p",[a("strong",[t._v("redux-promise:")]),t._v(" 处理异步的中间件")]),t._v(" "),a("p",[a("strong",[t._v("redux-saga")]),t._v(":用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。对于Saga，")]),t._v(" "),a("p",[a("strong",[t._v("比较")]),t._v(" "),a("strong",[t._v("1、redux-thunk 的缺点在于api层与store耦合，优点是比较灵活，易于控制")]),t._v(" "),a("br"),t._v(" "),a("strong",[t._v("2、redux-promise的优点是api层与store解耦，缺点是对请求失败，请求中的情形没有很好的处理")]),a("br"),t._v(" "),a("strong",[t._v("3、redux-saga 的优点是api层与store解耦，对请求中，请求失败都有完善的处理，缺点是代码量较大。")]),a("br")]),t._v(" "),a("p",[a("strong",[t._v("redux-dvtools")]),t._v(":可以用于调试redux中的状态更改，我们可以清晰的看到当前store仓库中的state是怎么样的，在可视化工具的左边，我们还可以看到触发的action的变化。")]),t._v(" "),a("h2",{attrs:{id:"_7-比较redux和vuex-flux的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-比较redux和vuex-flux的区别"}},[t._v("#")]),t._v(" 7.比较redux和vuex，Flux的区别")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("1、Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。")])]),t._v(" "),a("li",[a("p",[t._v("2、redux 不仅可以用在vue,react,其他一切需要状态管理的应用中")])]),t._v(" "),a("li",[a("p",[t._v("3、数据的流向不同")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("vuex的流向：")]),t._v(" "),a("ul",[a("li",[t._v("view——>commit——>mutations——>state变化——>view变化（同步操作）")]),t._v(" "),a("li",[t._v("view——>dispatch——>actions——>mutations——>state变化——>view变化（异步操作）")])])]),t._v(" "),a("li",[a("p",[t._v("redux的流向：")]),t._v(" "),a("ul",[a("li",[t._v("view——>actions——>reducer——>state变化——>view变化（同步异步一样）")])])])])]),t._v(" "),a("li",[a("p",[t._v("4、Vuex相对于Redux的不同点有:")]),t._v(" "),a("ul",[a("li",[t._v("（1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可")]),t._v(" "),a("li",[t._v("（2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可")]),t._v(" "),a("li",[t._v("（3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变(vue检测到数据变化自动渲染)")])])]),t._v(" "),a("li",[a("p",[t._v("5、Redux相对于Flux的改进：")]),t._v(" "),a("ul",[a("li",[t._v("（1）把store和Dispatcher合并,结构更加简单清晰新增state角色，代表每个时间点store对应的值，对状态的管理更加明确")]),t._v(" "),a("li",[t._v("（2）Redux数据流的顺序是:View调用store.dispatch发起Action->store接受Action(action传入reducer函数reducer函数返回一个新的state)->通知store.subscribe订阅的重新渲染函数")])])])]),t._v(" "),a("h2",{attrs:{id:"_8-react-router3是否用过-router4是否用过-3到4有什么改变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-react-router3是否用过-router4是否用过-3到4有什么改变"}},[t._v("#")]),t._v(" 8.react-router3是否用过，router4是否用过，3到4有什么改变")]),t._v(" "),a("ul",[a("li",[t._v("1、react-router3的包是react-router， router4的包是react-router-dom 最直观的是包发生了变化")]),t._v(" "),a("li",[t._v("2、API 发生了变化\n"),a("ul",[a("li",[t._v("V3 中的 Router 不在了，在 V3 中，我们是将整个庞大的 Router 直接丢给 DOM，而在 V4 中，除了 BrowserRouter，我们丢给 DOM 的是我们的应用程序本身")]),t._v(" "),a("li",[t._v("V4 中，我们不再使用 "),a("code",[t._v("{props.children}")]),t._v(" 来嵌套组件了，替代的 "),a("code",[t._v("<Route></Route>")]),t._v("，当 route 匹配时，子组件会被渲染到 "),a("code",[t._v("<Route></Route>")]),t._v(" 书写的地方")]),t._v(" "),a("li",[t._v("V4 中也没有 "),a("code",[t._v("<IndexRoute>")]),t._v("，但 "),a("code",[t._v("<Route exact>")]),t._v(" 可以实现相同的功能，或者 "),a("code",[t._v("<Switch>")]),t._v(" 和 "),a("code",[t._v("<Redirect>")]),t._v(" 重定向到默认的有效路径，甚至一个找不到的页面")])])]),t._v(" "),a("li",[t._v("3、路由匹配的规则发生了变化\n"),a("ul",[a("li",[t._v("V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 "),a("code",[t._v("<Route></Route>")]),t._v("，")]),t._v(" "),a("li",[t._v("V4 中的 routes 默认是 inclusive 的，这就意味着多个 "),a("code",[t._v("<Route>")]),t._v("可以同时匹配和呈现,通过 exact 这么一个 props，可以更改匹配的规则变成V3的匹配规则")])])])]),t._v(" "),a("h2",{attrs:{id:"_9-react是什么层面上的框架-数据流是单向流还是双向绑定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-react是什么层面上的框架-数据流是单向流还是双向绑定"}},[t._v("#")]),t._v(" 9.react是什么层面上的框架，数据流是单向流还是双向绑定")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",[t._v("react是应用层面的框架，react 本质上单向流，数据只能从父组件想组件传递")])]),t._v(" "),a("h2",{attrs:{id:"_10-react-render-callback-pattern-渲染回调模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-react-render-callback-pattern-渲染回调模式"}},[t._v("#")]),t._v(" 10.React Render Callback Pattern(渲染回调模式)")]),t._v(" "),a("h2",{attrs:{id:"高阶组件-hoc-而言-高阶组件是参数为组件-返回值为新组件的函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件-hoc-而言-高阶组件是参数为组件-返回值为新组件的函数"}},[t._v("#")]),t._v(" 高阶组件(HOC) : 而言，高阶组件是参数为组件，返回值为新组件的函数")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" EnhancedComponent "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("higherOrderComponent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("WrappedComponent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("当您想要重用组件逻辑时，高阶组件(简称HOC)非常有用。 它们是 JavaScript 函数，它将组件作为参数并返回一个新组件。")]),t._v(" "),a("ul",[a("li",[t._v("高阶组件存在的问题\n"),a("ul",[a("li",[t._v("静态方法丢失")]),t._v(" "),a("li",[t._v("refs 属性不能透传  React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：")]),t._v(" "),a("li",[t._v("反向继承不能保证完整的子组件树被解析")])])])]),t._v(" "),a("p",[t._v("难易程度 等级（!,!!,!!!）\n \n1.js的垃圾回收机制是什么原理（js）!!\n \n2.经常遇到的解决js兼容性问题列举至少三个（js）!\n \n3.不设置寛高的div，用至少两种方法，让它相对于页面水平垂直居中。（css）! --\x3e\n")])])}),[],!1,null,null,null);s.default=r.exports}}]);