---
title: æ§åˆ¶å°è¿›åº¦æ¡
date: 2020-04-15
tags:
  - Cli
categories:
  - Cli
---

## Cli æ§åˆ¶å°æ˜¾ç¤ºåŠ è½½è¿›åº¦ï¼Œå¹¶è¾“å‡ºæˆåŠŸä»¥åŠå¤±è´¥çš„çŠ¶æ€

::: tip
æœ€è¿‘ CLI é¡¹ç›®ä¸­æœ‰ä¸€ä¸ªç”¨æˆ·ä½“éªŒä¸æ˜¯å¾ˆå®Œç¾ç‚¹çš„ï¼Œå› ä¸ºéœ€è¦æ‰§è¡Œ cli å‘½ä»¤æ¥å‘é€ä¸€ä¸ªè¯·æ±‚åˆ°æœåŠ¡å™¨ï¼Œè™½ç„¶è¯·æ±‚å‘é€æˆåŠŸäº†ï¼Œä½†æ˜¯æœåŠ¡å™¨éœ€è¦åšä¸€äº›è§„åˆ™æ“ä½œï¼Œè¿™äº›è§„åˆ™æ“ä½œçš„æ—¶é—´ï¼Œæ²¡æœ‰åŠæ³•æ•è·åˆ°å¹¶ä¸”å“åº”ç»™ cli ä¸­ï¼Œæ€æ¥æƒ³å»ï¼Œé‡‡å–äº†ä¸€ä¸ªéšœçœ¼æ³•çš„æ“ä½œï¼Œå“ˆå“ˆå“ˆ
:::

## æ•ˆæœå›¾

:biking_man: **success**

![suucess](./image/success.gif)

:biking_man: **failed**

![failed](./image/failed.gif)

::: tip
é¦–å…ˆæ¥çœ‹è¿›åº¦æ¡çš„ä»£ç  ç›¸å¯¹æ¥è¯´æ¯”è¾ƒç®€å•ï¼Œä¸»è¦çš„ä½œç”¨å°±æ˜¯è®¡ç®—è¾“å‡º å®Œæˆçš„å­—ç¬¦å’Œæœªå®Œæˆçš„å­—ç¬¦æ‹¼æ¥è¿”å›çš„æ•´å­—ä¸²ï¼Œä»¥åŠå®Œæˆçš„ç™¾åˆ†æ¯”
:::

## åˆ†æ

```js
// TerminalProgress.js
class TerminalProgress {
  constructor(description) {
    // the description info è¿›åº¦æ¡å‰é¢çš„æè¿°
    this.description = description || "OnProgress";
    // the render str length è¿›åº¦æ¡çš„é•¿åº¦ï¼ˆè¿™ç©æ„æœ€å¥½åˆ«å¤ªé•¿ï¼Œè¶…è¿‡æ§åˆ¶å°é•¿åº¦è¾“å‡ºå°±ç•¥æ˜¾æœ‰ç‚¹bugï¼‰
    this.length = 50;
  }
  /**
   * @Parmas opts {Object}
   * @Parmas opts.completed {Number}
   * @Parmas opts.total {Number}
   *
   * @return Result {Object}
   * @return Result.description {String}
   * @return Result.complete    {String}
   * @return Result.uncomplete  {String}
   * @return Result.progressNum {Number}
   */

  renderOption(opts) {
    // Calculate progress (completed / total)
    let percent = (opts.completed / opts.total).toFixed(4);
    // the complete str length
    let cell_num = Math.floor(percent * this.length);

    // complete str
    let complete = "";
    for (let i = 0; i < cell_num; i++) {
      complete += "â–ˆ";
    }

    // uncompleted str
    let uncomplete = "";
    for (let i = 0; i < this.length - cell_num; i++) {
      uncomplete += "â–‘";
    }
    //
    let progressNum = `${(100 * percent).toFixed(2)}%`;

    return { description: this.description, complete, uncomplete, progressNum };
  }
}

module.exports = TerminalProgress;
```

::: tip
æœ‰äº†ä¸Šé¢çš„è¿›åº¦ä¸²ï¼Œå°±è¦æ€è€ƒè¿™ä¸ªä¸œè¥¿åº”è¯¥è¿è¡Œåœ¨å“ªé‡Œ</br>
1ã€ç›´æ¥åœ¨ä¸»è¿›ç¨‹ä¸­è¿è¡Œå…ˆåŠ è½½å®Œè¿›åº¦ä¸²å†å‘é€è¯·æ±‚-è¿™ä¸ªåšæ³•ç®€ç›´äº† enenene, å‘é€è¯·æ±‚å¤±è´¥äº†æ€ä¹ˆåŠï¼Ÿï¼Œæç¤ºç”¨æˆ·æ‰§è¡ŒæˆåŠŸäº†ï¼Œä½†æ˜¯åé¢åˆå¤±è´¥ï¼Œå¿ƒå£ä¸ä¸€å•ªå•ªæ‰“è„¸ âœ– ğŸ˜‚ğŸ˜‚ğŸ˜‚ </br>
2ã€è¿è¡Œåœ¨å­è¿›ç¨‹ä¸­ï¼Œä¸»è¿›ç¨‹åŠ è½½å­è¿›ç¨‹è¿è¡Œè¿›åº¦ä¸²ï¼Œç„¶åä¸»è¿›ç¨‹åœ¨å»å‘é€è¯·æ±‚ï¼Œè¯·æ±‚å‘é€æˆåŠŸï¼Œä¸»è¿›ç¨‹é€šè¿‡è¿›ç¨‹é€šä¿¡å‘Šè¯‰å­è¿›ç¨‹ï¼Œè¿™ä¸ªä½ å°±é¡ºåˆ©æ‰§è¡Œå®Œæˆå°± OKï¼Œå¦‚æœå‘é€å¤±è´¥ï¼Œåœ¨å‘Šè¯‰å­è¿›ç¨‹è¿™ä¸ªä¸ OKï¼Œè§çº¢ã€‚</br>
3ã€æ‰§è¡Œ main ä¸»è¿›ç¨‹ åŠ è½½å­è¿›ç¨‹è¾“å‡ºè¿›åº¦ä¸²ï¼Œå¹¶ä¸”ä¸»è¿›ç¨‹è®¾ç½®å®šæ—¶å™¨ï¼Œåœ¨ä¸€å®šçš„æ—¶é—´ä»¥å å‘èµ·è¯·æ±‚å¹¶åˆ¤æ–­ å“åº”æ˜¯å¦ OK å¦‚æœ OKï¼Œåœ¨æ­¤å‘å­è¿›ç¨‹ send æ•°æ®ã€‚
:::

```js
// child_process.js
let chalk = require("chalk"); // é¢œè‰²æ¨¡å—
let slog = require("single-line-log").stdout; // è¾“å‡ºå­—ç¬¦åœ¨ä¸€è¡Œ
const TerminalProgress = require("./TerminalProgress"); // å¯¼å…¥è¿›åº¦ä¸² å¹¶å®ä¾‹åŒ–
const terminalProgress = new TerminalProgress("On Publishing");
var Timer = null;

// å­è¿›ç¨‹ç›‘å¬ message äº‹ä»¶
process.on("message", (value) => {
  render(value);
});

function render(value) {
  let num = value.num;
  let total = value.total;
  let status = value.status;
  let time = value.time;
  if (Timer) {
    clearInterval(Timer);
  }
  Timer = setInterval(() => {
    if (num <= total) {
      let {
        description,
        complete,
        uncomplete,
        progressNum,
      } = terminalProgress.renderOption({ completed: num, total: total });
      if (status) {
        let renderString = `${description}: ${chalk.green(
          complete
        )}${uncomplete}  ${progressNum} \n\n`;
        slog(renderString);
      } else {
        let renderString = `${description}: ${complete}${uncomplete}  ${progressNum} \n\n`;
        slog(chalk.red(renderString));
      }
      num++;
    } else {
      clearInterval(Timer);
      // é€€å‡ºå½“å‰è¿›ç¨‹
      process.exit(status);
    }
  }, time);
}
```

::: tip
ä¸»è¿›ç¨‹ä»£ç 
:::

```js
// main.js
const path = require("path");
const chalk = require("chalk");
const child_process = require("child_process");
console.log(" ");

let buildTime = 300; //
let publishTime = parseInt(Date.now() / 1000);
let leadTime = buildTime - publishTime < 0 ? 180 : buildTime - publishTime;
let thirtyPercentTime = leadTime * 0.3;
let countDownTime = 500;

let pathString = path.resolve(__dirname, "./child_process.js");
// fork ä¸€ä¸ªå­è¿›ç¨‹å¹¶åŠ è½½è¿è¡Œ
const subprocess = child_process.fork(pathString);
// æƒ³å­è¿›ç¨‹å‘é€åˆå§‹åŒ–æ•°æ®
subprocess.send({ num: 0, total: leadTime, status: true, time: countDownTime });
// ç›‘å¬å­è¿›ç¨‹çš„è¿è¡ŒçŠ¶æ€
subprocess.on("close", async (value) => {
  if (value) {
    console.log(chalk.green(`å‘å¸ƒæˆåŠŸ`));
  } else {
    console.log(chalk.red("å‘å¸ƒå¤±è´¥"));
  }
  process.exit(0);
});

let setFunction = async (count) => {
  let isPublishOK = await asyncRequest();
  if (isPublishOK) {
    subprocess.send({
      num: parseInt(leadTime * (count / 10)),
      total: leadTime,
      status: true,
      time: 100,
    });
  } else {
    if (count == 6) {
      subprocess.send({
        num: parseInt(leadTime * (count / 10)),
        total: leadTime,
        status: false,
        time: 50,
      });
    } else {
      setTimeout(setFunction, thirtyPercentTime * countDownTime, 6);
    }
  }
};

setTimeout(setFunction, thirtyPercentTime * countDownTime, 3);

async function asyncRequest() {
  // do something
  return true;
}
```

## å»¶ä¼¸

:::
é™¤è¿‡ä½¿ç”¨å­è¿›ç¨‹è¿˜å¯ä»¥ä½¿ç”¨ woker çº¿ç¨‹ï¼Œæ¥åŠ è½½è¿è¡Œè¿›åº¦ä¸²
:::

```js
// Woker.js
let slog = require("single-line-log").stdout;
let chalk = require("chalk");
// ä½¿ç”¨äº† è¿™ä¸ªåº“
const { parentPort, workerData } = require("worker_threads");
const TerminalProgress = require("./TerminalProgress");
const terminalProgress = new TerminalProgress("On Publishing", workerData - 30);
var Timer = null;
parentPort.on("message", (value) => {
  render(value);
});

function render(value) {
  let num = value.num;
  let total = value.total;
  let status = value.status;
  let time = value.time;
  if (Timer) {
    clearInterval(Timer);
  }

  Timer = setInterval(() => {
    if (num <= total) {
      let {
        description,
        complete,
        uncomplete,
        progressNum,
      } = terminalProgress.renderOption({ completed: num, total: total });
      if (status) {
        let renderString = `${description}: ${chalk.green(
          complete
        )}${uncomplete}  ${progressNum} \n\n`;
        slog(renderString);
      } else {
        let renderString = `${description}: ${complete}${uncomplete}  ${progressNum} \n\n`;
        slog(chalk.red(renderString));
      }

      num++;
    } else {
      clearInterval(Timer);
      parentPort.postMessage(status);
      process.exit(0);
    }
  }, time);
}
```

```js
// main.js
// .... çœç•¥ ....
let pathString = path.resolve(__dirname, "./Woker.js");
const worker = new Worker(pathString, { workerData: process.stdout.columns });
worker.postMessage({
  num: 0,
  total: leadTime,
  status: true,
  time: countDownTime,
});
worker.on("message", (value) => {
  if (value) {
    console.log(chalk.green(`æˆåŠŸ`));
  } else {
    console.log(chalk.red("å¤±è´¥"));
  }
  process.exit(0);
});
// .... çœç•¥ ....
```
