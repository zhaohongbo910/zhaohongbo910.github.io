---
title: Node 基础知识
date: 2017-12-13
permalink: /:year/:month/:day/:slug
tags:
 - JavaScript       
categories: 
 - Node 
---


## DOS基本命令
- DOS命令窗口的打开=>win+R=>运行命令窗口中输入cmd
- 查看自己的ip地址: ipconfig/ipconfig all
- 查看自己的网络状态: ping www.baidu.com -t
- 终止正在运行的DOS命令: ctrl+c
- 关掉DOM命令窗口: exit
- 清屏幕: cls
- 跳转到指定目录: cd
- cd .跳转到当前目录 cd ..跳转到上级目录 cd 返回当前home目录 cd /跳转到根目录
- 查看当前目录下有那些文件夹: dir
- 查看当前目录下有那些文件和文件夹: ls
- 创建文件: touch 文件名
- 创建目录: md/mkdir 目录名
- 删除目录: rd/rm 目录名

## 搭建一个自己的网站需要那些步骤
- 前后台开发(网站代码首先有)
- 买服务器(云服务器), 服务器连接上网络后, 会有一个外网的ip地址(说白了就是买一台服务器会给你一个外网地址), 拥有外网地址后, 将开发的代码都上传到服务器上(ftp上传) 
- 买域名(万网)
- 进行DNS解析(域名解析), DNS是一个网络服务器, 我们的域名解析其实就是在DNS上记录一条信息记录
> www.xiaobuding.com      220.114.23.56(服务器外网ip地址) 80(服务器端口号)


> DNS解析介绍
```
DNS介绍:
人们习惯记忆域名，但机器间互相只认IP地址，域名与IP地址之间是多对一的关系，一个ip地址不一定只对应一个域名，且一个域名只可以对应一个ip地址，它们之间的转换工作称为域名解析，域名解析需要由专门的域名解析服务器来完成，整个过程是自动进行的。

原理:
当你的网站制作完成后上传到你的虚拟主机时，你可以直接在浏览器中输入IP地址浏览你的网站，也可以输入域名查询你的网站，虽然得出的内容是一样的但是调用的过程不一样，输入IP地址是直接从主机上调用内容，输入域名是通过域名解析服务器指向对应的主机的IP地址，再从主机调用网站的内容。

DNS解析的过程:
最简单的响应是一个地址记录（也称A记录）。当客户端创建了一个查询时，该域下授权的DNS服务器会响应一个或多个IP地址。
这里没有固定的顺序，这个地址通常是随机排序的。另一个客户得到的结果顺序可能是完全不一样的。我们的客户会选择其中一个IP。如果只返回一个独立的IP，这个选择过程就会非常短。
规范名字记录：不只是响应一个特定的IP，服务器还可以返回一个规范名字（CNAME）记录。CNAME是将多个完全限定域名（FQDN）指向一个主机的快捷方式。
当服务器到那以后，它可能会发现另一个CNAME记录，和另一个一样。我在复杂的网络环境和广告软件或跟踪平台中看到过，每个过程都委托给其他人，为一个你不想做的链接找到一个真正的IP地址是非常困难的。
```

## 客户端和服务器端的交互模型
> 思考: 当用户在浏览器中输入一个网址后, 到最后看到页面的内容发生了那些事情??
### 交互模型的构成
> 客户端
- 1: 在浏览器中输入要访问的域名和端口号以及要访问的具体项目文件
- 2: 接收到服务器返回的文件(html, css, js…..)后解析渲染， 显示到浏览器中

> 服务器
- 1: 通过ftp将项目文件上传到指定的端口号下
- 2: 根据客户端的请求内容将客户端要访问的文件获取后返回给客户端

> DNS域名解析
- 1: 通过域名找到服务器ip地址(域名解析)
- 2: 通过端口号找到对应的服务器下的项目
- 3: 通过index.html到对应项目中找到指定index.html文件

## 相关概念的介绍
- 端口号: 我们一台服务器上可以存放多个项目, 每一个项目都有一个自己对应的房间或者区域, 服务器使用端口号来区分具体是哪一个项目
> 端口号范围: 0~65535, 所以理论上一台服务器上可以发布65535个项目, 但是一台服务器一般不会发布那么多项目, 一般也就是几个, 一般我们都把项目发布到80/443端口号下

- 浏览器渲染: 服务器通过报文将客户端需要获取的资源文件源码返回给客户端后, 客户端浏览器需要将源码进行渲染, 显示出页面
> 渲染引擎: 谷歌: v8引擎(webkit)  火狐: Gecko引擎  ie: Trident引擎


## URL请求地址的构成
- URL：Uniform Resource Locator，统一资源定位符；
- URN：Uniform Resource Name，统一资源名称。
- URI：Uniform Resource Identifier，统一资源标识符 = URL+URN；
> 例如: http://www.chenchao.com:80/index.html?name=baizhi&age=18#bbs
- http: 超文本传输协议=>客户端给服务器的内容和服务器传递给客户端的内容(报文)都是通过http传输协议进行传输的(可以把http理解为快递员)
- www.chenchao.com: 域名=>到DNS中通过域名找到服务器ip地址
- 80: 端口号=>找到指定的项目
- index.html: 请求资源文件名=>找到指定项目的指定文件
- ?name=baizhi&age=18: url请求参数=>客户端传递给服务器端的信息(比如: 提交用户信息的时候将通过get请求, 将用户信息通过url传参的形式传递服务器)
> url传参, 是客户端传递给服务器参数的一种方式, 还可以通过请求体方式进行传参(url传参一般是get请求, 请求体传参一般是post请求)
- $bbs: URL中的hash值(锚点定位)

## 传输协议
- http超文本传输协议, 除了传输文本外还可以传输其他的东西, 例如: xml等
- https更加安全的http, 在http基础上加速ssl层
- ftp文件传输协议(应用于把项目源文件传递到服务器上)
> 在不指定访问的服务器端口的情况下, 每种协议都会有一个默认找的端口地址
- http: 80
- https: 443
- ftp: 21

### 客户端服务器端代码编写
> 客户端
- html/css/js....
> 服务器
- java/php/.net/js

### 什么是node
> 什么是js?
- js是一门运行在客户端(浏览器)的轻量级的脚本编程语言
> 思考: 如何在浏览器中运行js代码??
- 首先创建html文件, 需要在html中使用script标签引入js代码, 在浏览器中运行html文件, 并在浏览器中渲染所有的html/css/js代码
- 现在js不仅可以在浏览器中运行还可以在node中运行
> 什么是node?
- node是一个环境不是编程语言, 就像浏览器环境一样, 提供了一种可以直接运行js代码的环境, 我一般会把node环境安装在服务器端, 而浏览器是安装在客户端, 这样我们就可以在服务器端使用js编写程序了, 也就是说js不仅仅可以编写前客户端的语言还可以编写服务器的语言....


### node和浏览器的区别
- 浏览器安装在客户端的, 为了保护客户端的安全, 基本上不会提供js代码操作客户端磁盘上的文件功能, node是安装服务端的, node提供了一系列js代码操作服务器磁盘上的文件功能(比如:客户端访问index.html文件, 服务器需要通过fs模块读取index.html文件代码发送给客户端)
- node采用的是谷歌的v8引擎来解析js代码的, 浏览器渲染引擎根据浏览器的不同也是有所差异的
- 浏览器中的全局js对象是window, 而node环境下的全局对象是global
- node环境下给js提供了很多新的模块和方法(http, fs, url, express....)

### node环境下运行js程序
> 练习: 编写一段js代码, 实现任意多个数求和
```js
function sum(){
    var total = 0;
    for (var i=0; i<arguments.length; i++){
        var cur = Number(arguments[i]);
        if (!isNaN(cur)){
            total += cur;
        }
    }
    return total;
}
console.log(sum(1, 2, 3, 4, 5));
```
> 前提是在webstorm中绑定node环境 / vscode 中安装 .run 插件  右击当前窗口 `run`  
- webstorm中右键执行: 如果在webstorm中已经注入node环境后, 直接在js文件中右键'run xxx.js'在node环境中直接执行即可
> 前提是安装了node全局命令
- webstorm中命令行执行: 打开webstorm中的terminal命令行, 直接输入node xxx.js命令即可
- 终端命令行执行: 找到js文件所在的目录, shift+右键->在此处打开命令行窗口->执行node xxx.js命令即可

## node中的模块
- 为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。
- 模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块。

### node中模块的分类
- 内置模块: node环境中自行提供的模块(http, fs, url...)
- 自定义模块: 我们自己定义的模块, 一个js文件就可以理解为一个自定义模块
- 第三方模块: 别人写好的模块, 我们直接使用(node中如果需要使用别人编写的模块, 需要使用npm命令进行安装)
> 例如: 安装less模块, npm install less 卸载less模块: npm uninstall less

### node中自定义模块的导出
- 我们自己创建的模块只有导出后在其他模块中才能使用, 不导出, 外界模块是没法使用的
- 自定义模块中导出方式可以通过module.exports和exports
```js
function sumAdd(){
    var total = 0;
    for (var i=0; i<arguments.length; i++){
        var cur = Number(arguments[i]);
        if (!isNaN(cur)){
            total += cur;
        }
    }
    return total;
}
function sumDel(){
    var total = 0;
    for (var i=0; i<arguments.length; i++){
        var cur = Number(arguments[i]);
        if (!isNaN(cur)){
            total -= cur;
        }
    }
    return total;
}

/**
 * 模块的导出方式:
 * module.exports和exports
 * */

//单独导出每个方法
module.exports.sumAdd = sumAdd;
module.exports.sumDel = sumDel;

//批量到处多个方法
module.exports.sum = {
    sumAdd:sumAdd,
    sumDel:sumDel
};
```

> 练习: 导出一个构造方法, 通过该构造方法创建一个实例并调用其中的方法
> person.js自定义模块
```js
module.exports = function (age, name) {
    this.age = age;
    this.name = name;
    this.about = function () {
        console.log(this.age, this.name);
    }
};
```
> 使用自定义模块
```js
var Person = require('./person');
var person = new Person(18, 'chenchao');
person.about();
```


### node中模块的加载
> node中模块的加载使用require
- 内置模块: require('http'); 直接写内置的模块名即可
- 自定义模块: require('./index.js') 必须有./, 不能省略当前目录./, 否则会被认为是查找内置模块, 文件后缀名可以省略
- 第三方模块: require('express'); 直接写第三方模块名
> 注意: ./开头的是自定义模块, 没有./的可能是内置也可能是第三方模块

### node的内置模块使用
- http模块: 创建服务器, 监听端口号, 监听客户端的请求, 获取客户端的请求报文, 返回给客户端相应的信息
- fs模块: 文件的操作, 读取, 写入.....
- url模型: 客户端请求url地址的解析(路径pathname和参数query)

> http模块的介绍
 ```js
 /**
  * http模块:
  * 1: 创建服务端
  * 2: 监听端口号
  * 3: 获取客户端请求信息
  * 4: 根据客户端的请求返回给客户端指定信息
  * */
 var http = require('http'); //内置模块的倒入

 /**
  * createServer 创建一个服务端, 返回值就是创建的服务对象
  * */
 var server = http.createServer();

 //监听指定的端口号(当前项目的端口是8080)
 /**
  * listen: 监听指定的端口号
  * 参数1: 监听的端口号
  * 参数2: 监听成功的回调
  * */
 server.listen(8080, function () {
     console.log('server is success, listening 8080...');
 });
 ```
 > 思考: 上述代码只是监听了客户端的请求, 但是客户端什么时候到来我们并不知道, 如何知道客户端当前请求到达?
```js
/**
 * http模块:
 * 1: 创建服务端
 * 2: 监听端口号
 * 3: 获取客户端请求信息
 * 4: 根据客户端的请求返回给客户端指定信息
 * */
var http = require('http'); //内置模块的倒入

/**
 * createServer 创建一个服务端, 返回值就是创建的服务对象
 * 参数1: 回调方法
 * 该回调方法是在客户端想服务器发送请求的时候, 服务器监听到有客户端的请求到来的时候, 触发该回调方法
 * */
var server = http.createServer(function () {
    console.log('监听到有客户端请求到来....');
});

//监听指定的端口号(当前项目的端口是8080)
/**
 * listen: 监听指定的端口号
 * 参数1: 监听的端口号
 * 参数2: 监听成功的回调
 * */
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```

> 思考: 此时我们已经监听到客户端的请求到来, 但是没有做任何的处理, 也不知道客户端请求的信息是什么??
```js
/**
 * http模块:
 * 1: 创建服务端
 * 2: 监听端口号
 * 3: 获取客户端请求信息
 * 4: 根据客户端的请求返回给客户端指定信息
 * */
var http = require('http'); //内置模块的倒入
/**
 * createServer 创建一个服务端, 返回值就是创建的服务对象
 * 参数1: 回调方法
 * 该回调方法是在客户端想服务器发送请求的时候, 服务器监听到有客户端的请求到来的时候, 触发该回调方法
 * 回调方法中的两个参数: req, res
 * req: 保存了客户端想服务器发送的所有请求信息(请求头url和请求体)
 * res: 通过res服务器可以相客户端返回相应的信息, 服务器可以在res对象上设置相应信息具体内容(响应头, 相应体)
 * */
var server = http.createServer(function (req, res) {
    console.log('监听到有客户端请求到来....');
    console.log(req);
    console.log(res);
});

//监听指定的端口号(当前项目的端口是8080)
/**
 * listen: 监听指定的端口号
 * 参数1: 监听的端口号
 * 参数2: 监听成功的回调
 * */
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```

> 通过req.url获取请求的url地址信息, 如何解析该url地址, 获取请求的地址, 请求的参数信息呢 ??
```js
/**
 * http模块:
 * 1: 创建服务端
 * 2: 监听端口号
 * 3: 获取客户端请求信息
 * 4: 根据客户端的请求返回给客户端指定信息
 * */
var http = require('http'); //内置模块的倒入

/**
 * url模块:
 * 用于对客户端请求的url进行解析
 * 1: 获取客户端请求路径
 * 2: 获取客户端请求参数
 * */
var url = require('url');

/**
 * createServer 创建一个服务端, 返回值就是创建的服务对象
 * 参数1: 回调方法
 * 该回调方法是在客户端想服务器发送请求的时候, 服务器监听到有客户端的请求到来的时候, 触发该回调方法
 * 回调方法中的两个参数: req, res
 * req: 保存了客户端想服务器发送的所有请求信息(请求头url和请求体)
 * res: 通过res服务器可以相客户端返回相应的信息, 服务器可以在res对象上设置相应信息具体内容(响应头, 相应体)
 * */
var server = http.createServer(function (req, res) {
    console.log('监听到有客户端请求到来....');
    /**
     * http://localhost:8080/index.html?username=ssdf&content=sffsdfd
     * req.url是获取的请求的url地址, 这是req中最常用的属性, 通过url地址的解析,可以获取客户端请求的具体文件, 请求url中的参数信息
     * */
    console.log(req.url);
    console.log(url.parse(req.url));
    /**
     * parse: 通过url模块对人客户端请求地址req.url进行解析
     * 参数1: 解析的url地址
     * 参数2: query解析成对象
     * pathname: 客户端请求路径=>获取客户端想要访问的文件
     * query: 客户端请求参数=>获取客户端请求传递的参数
     * */
    var urlObj = url.parse(req.url, true);
    console.log(urlObj.pathname);
    console.log(urlObj.query);

});

//监听指定的端口号(当前项目的端口是8080)
/**
 * listen: 监听指定的端口号
 * 参数1: 监听的端口号
 * 参数2: 监听成功的回调
 * */
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```

> url模块介绍
```js
var url = require('url');

var urlStr = 'http://localhost:8080/index.html?username=ssdf&content=sffsdfd#bbs';

//传递true
console.log(url.parse(urlStr));
//没有传递true
console.log(url.parse(urlStr, true));
/**
 * 传递true和不传递的区别
 * query: 请求参数的类型, 没有true是字符串, 如果有true, 变成对象
 * */


/*Url {
    protocol: 'http:', //传输协议
    slashes: true,
    auth: null,
    host: 'localhost:8080', //域名+端口
    port: '8080',          //端口
    hostname: 'localhost',  //域名
    hash: '#bbs',          //hash值
    search: '?username=ssdf&content=sffsdfd', //传递进来的的数据
    query: 'username=ssdf&content=sffsdfd', //传递进来的的数据(不包含问好)
    pathname: '/index.html',  //路径
    path: '/index.html?username=ssdf&content=sffsdfd',//路径后面所有的数据
    href: 'http://localhost:8080/index.html?username=ssdf&content=sffsdfd' }*/


/*
Url {
    protocol: 'http:',
        slashes: true,
        auth: null,
        host: 'localhost:8080',
        port: '8080',
        hostname: 'localhost',
        hash: '#bbs',
        search: '?username=ssdf&content=sffsdfd',
        query: 'username=ssdf&content=sffsdfd',
        pathname: '/index.html',
        path: '/index.html?username=ssdf&content=sffsdfd',
        href: 'http://localhost:8080/index.html?username=ssdf&content=sffsdfd#bbs' }
Url {
    protocol: 'http:',
        slashes: true,
        auth: null,
        host: 'localhost:8080',
        port: '8080',
        hostname: 'localhost',
        hash: '#bbs',
        search: '?username=ssdf&content=sffsdfd',
        query: { username: 'ssdf', content: 'sffsdfd' },
    pathname: '/index.html',
        path: '/index.html?username=ssdf&content=sffsdfd',
        href: 'http://localhost:8080/index.html?username=ssdf&content=sffsdfd#bbs' }*/
```

> 服务器需要根据客户端请求的信息, 读取index.html文件的内容, 返回给客户端, 如何读取文件内容 ??
```js
/**
 * http模块:
 * 1: 创建服务端
 * 2: 监听端口号
 * 3: 获取客户端请求信息
 * 4: 根据客户端的请求返回给客户端指定信息
 * */
var http = require('http'); //内置模块的倒入

/**
 * url模块:
 * 用于对客户端请求的url进行解析
 * 1: 获取客户端请求路径
 * 2: 获取客户端请求参数
 * */
var url = require('url');

/**
 * fs模块:
 * 1: 读取指定文件中的内容
 * 2: 想文件中写入指定内容
 * */
var fs = require('fs');

/**
 * createServer 创建一个服务端, 返回值就是创建的服务对象
 * 参数1: 回调方法
 * 该回调方法是在客户端想服务器发送请求的时候, 服务器监听到有客户端的请求到来的时候, 触发该回调方法
 * 回调方法中的两个参数: req, res
 * req: 保存了客户端想服务器发送的所有请求信息(请求头url和请求体)
 * res: 通过res服务器可以相客户端返回相应的信息, 服务器可以在res对象上设置相应信息具体内容(响应头, 相应体)
 * */
var server = http.createServer(function (req, res) {
    console.log('监听到有客户端请求到来....');
    /**
     * http://localhost:8080/index.html?username=ssdf&content=sffsdfd
     * req.url是获取的请求的url地址, 这是req中最常用的属性, 通过url地址的解析,可以获取客户端请求的具体文件, 请求url中的参数信息
     * */
    console.log(req.url);
    console.log(url.parse(req.url));
    /**
     * parse: 通过url模块对人客户端请求地址req.url进行解析
     * 参数1: 解析的url地址
     * 参数2: query解析成对象
     * pathname: 客户端请求路径=>获取客户端想要访问的文件
     * query: 客户端请求参数=>获取客户端请求传递的参数
     * */
    var urlObj = url.parse(req.url, true);
    console.log(urlObj.pathname);
    console.log(urlObj.query);


    /**
     * readFileSync同步的方式读取文件:
     * 参数1: 读取的文件名
     * 参数2: 编码格式
     * 返回值就是读取的内容, 字符串类型
     * */
    var con = fs.readFileSync('index.html', 'utf8');

    /**
     * write将读取的内容返回给客户端
     * 注意: 默认客户端和服务器之间传递的数据类型只能是buffer和string类型
     * */
    res.write(con);
    res.end();//结束发送

});

//监听指定的端口号(当前项目的端口是8080)
/**
 * listen: 监听指定的端口号
 * 参数1: 监听的端口号
 * 参数2: 监听成功的回调
 * */
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```

## 静态资源文件处理
> 创建客户端文件: index.html, index.css, index.js文件
- index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
<div class="box" id="box"></div>
</body>
<script src="js/index.js"></script>
</html>
```
- index.css
```css
*{
    margin: 0;
    padding: 0;
}
body, html{
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    font-size: 14px;
}
.box{
    width: 100px;
    height: 100px;
    background: lightseagreen;
}
```
- index.js
```js
var oBox = document.getElementById('box');

oBox.onclick = function () {
    this.style.background = 'green';
};
```

> 创建服务端文件: server.js, 处理对css, js, html文件的处理
> 解析index.html文件
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    //如果请求的是/index.html文件
    if (pathname == '/index.html'){
        var con = fs.readFileSync('./index.html', 'utf8');  //读取index.html内容

        res.writeHead(200, {"content-type":"text/html;charset=utf8"});//发送请求头, 告诉客户端用解析html格式文件的方法解析con的内容

        res.end(con);//返回信息给客户端
    }

});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```
> 思考: 因为在index.html文件中link和script了css和js文件, 所以还需要在server中进行css和js文件的处理
- 练习: 实现css和js文件的请求
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    //如果请求的是/index.html文件
    if (pathname == '/index.html'){
        var con = fs.readFileSync('./index.html', 'utf8');  //读取index.html内容

        res.writeHead(200, {"content-type":"text/html;charset=utf8"});//发送请求头, 告诉客户端用解析html格式文件的方法解析con的内容

        res.end(con);//返回信息给客户端
    }

    //如果请求的是/index.html文件
    if (pathname == '/css/index.css'){
        var con = fs.readFileSync('./css/index.css', 'utf8');  //读取index.html内容

        res.writeHead(200, {"content-type":"text/css;charset=utf8"});//发送请求头, 告诉客户端用解析html格式文件的方法解析con的内容

        res.end(con);//返回信息给客户端
    }

    //如果请求的是/index.html文件
    if (pathname == '/js/index.js'){
        var con = fs.readFileSync('./js/index.js', 'utf8');  //读取index.html内容

        res.writeHead(200, {"content-type":"text/application;charset=utf8"});//发送请求头, 告诉客户端用解析html格式文件的方法解析con的内容

        res.end(con);//返回信息给客户端
    }

});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```

> 观察代码, 如何优化三个if判断
- 请求ico的时候, 读取失败, 服务器崩溃如何优化??
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    //如果请求的是/index.html文件
        var con = fs.readFileSync('.'+pathname, 'utf8');  //读取index.html内容

        res.end(con);//返回信息给客户端

});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```
- try-catch捕获异常
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    /**
     * try-catch
     * 如果请求的资源文件存在, 读取资源文件内容返回给客户选
     * 如果资源文件不存在, 直接返回404, 告诉客户端, 请求的资源文件不存在
     * */

    //如果请求的是/index.html文件
    try {
        var con = fs.readFileSync('.' + pathname, 'utf8');  //读取index.html内容
        res.end(con);//返回信息给客户端
    }catch (err){
        res.writeHead('404', {'content-type': "text/plain;charset=utf8"});
        res.end('request file is not find');//返回信息给客户端
    }

});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```
> 静态资源文件处理最终代码(能够接受客户端端请求html,js, css文件)
- MIME类型: 每一种资源文件都有一个自己的标识类型, 浏览器会按照标识类型MIME去渲染对应的文件
> 常见对应关系: html->text/html, js->application/js, css->text/css, json->application/json, txt->text/plain
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    /**
     * 思考: 客户端在解析服务器返回的html, css, js文件内容的时候, 客户端是如何知道该怎么解析文件的内容, 因为文件内容不同
     * 这时候服务器在请求头中加上mime信息, 告诉客户端应该用什么方式来解析当前的文件内容
     * html文件-->text/html
     * css文件-->text/css
     * js文件-->text/application
     * 文本文件->text/plain
     * json文件->application/json
     * */
    var reg = /\.(HTML|CSS|JS|TXT|JSON|ICO)/i;
    if (reg.test(pathname)){ //如果请求的文件包含正则中的内容
        var suffix = reg.exec(pathname)[1].toUpperCase();//获取请求文件的后缀名, 转换成大写
        var suffixMIME = 'text/html';//默认是html文件

        switch (suffix){ //通过检索的pathname的后缀名, 获取对应的MIME类型
            case 'HTML': {
                suffixMIME = 'text/HTML';
            } break;
            case 'CSS': {
                suffixMIME = 'text/css';
            } break;
            case 'JS': {
                suffixMIME = 'text/application';
            } break;
            case 'JSON': {
                suffixMIME = 'application/json';
            } break;
            case 'TXT': {
                suffixMIME = 'text/plain';
            } break;
        }

        /**
         * try-catch
         * 如果请求的资源文件存在, 读取资源文件内容返回给客户选
         * 如果资源文件不存在, 直接返回404, 告诉客户端, 请求的资源文件不存在
         * */

        //如果请求的是/index.html文件
        try {
            var con = fs.readFileSync('.' + pathname, 'utf8');  //读取index.html内容
            res.writeHead(200, {'content-type':suffixMIME+';charset=utf8'});//返回响应头, 告诉客户端当前文件的mime类型, 这样客户端就可以按照mime类型正确解析即可, charset=utf8指定返回的内容格式是utf8格式编号的, 返回的中文汉字就不回出现乱码了
            res.end(con);//返回信息给客户端
        }catch (err){
            res.writeHead(404, {'content-type': "text/plain;charset=utf8"});
            res.end('request file is not find');//返回信息给客户端
        }
    }
});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```




## http请求和响应报文

### 练习: 绘制服务器和客户端数据请求模型

### http事务
- 事务: 一件完整的事情称之为事务
- http事务: 一个完整的客户端和服务端数据交互(http事务: request+response)

### http报文
> 客户端传递给服务器的内容, 和服务器返回给客户端的内容都是http报文
> http报文的组成
- 起始行: 请求起始行, 响应起始行
- 首部: 请求首部, 响应首部, 通用首部, 自定义首部
- 主体: 请求主体, 响应主体

### 如何在控制台下查看报文
> 运行静态资源文件处理项目, 在谷歌控制台的network下查看

> 通用首部
```
eneral: ->通用首部
Request URL:http://localhost:8080/index.html (请求url)
Request Method:GET  (请求方式: get, post, delete, put, header, option)
Status Code:200 OK  (状态码)
Remote Address:[::1]:8080  (ip地址和端口号)
```
> 请求头
```
Request Headers -> 请求头
请求起始行:
GET /index.html HTTP/1.1 (请求起始行： get(请求方式) /index.html(请求路径) http/1.1(http版本号)
请求首部:
Host: localhost:8080
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.143 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Encoding: gzip, deflate, sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: Hm_lvt_e134fee1edb436d9a4b58261f92fdeb8=1476863452; Hm_lvt_403e4ac6a63f15f75c5b6fca09baaca4=1476863452
```

> 响应头
```
Response Headers: -> 响应头
响应起始行:
HTTP/1.1 200 OK (HTTP/1.1: http版本, 200: http响应状态码, OK: 状态吗的说明)
响应首部: 服务器传递给客户端的一些信息可以放在响应首部中, 客户端可以在响应首部中获取到相关信息
content-type: text/HTML;charset=utf8(告诉客户端mime类型, 客户端解析当前文件方式)
Date: Thu, 20 Oct 2016 06:58:25 GMT(服务器响应时间, 格林尼治时间+8是北京时间)
Connection: keep-alive
Transfer-Encoding: chunked
```
> 响应主体
```
Response: ->响应主体, 服务器传递给客户端的数据内容都是在响应主体中, 客户端可以在响应的主体中获取到这些内容(服务器设置 客户端获取)
```

> 请求主体
```
Request Payload: ->请求主体, 如何客户端通过post方式请求的时候, 可以通过请求体向服务器发送信息
```

### http请求方式
> 客户端向服务器发送请求的时候可以通过以下几种方式, 既可以向服务器传递数据也可以从服务器获取数据, 从本质意义上下面的请求方式是没有区别的, 但是开发人员有自己的约定和规范
- get: 一般应用于从服务器获取数据(向服务器传递的数据少, 获取服务器的信息多, 最常用的就是get请求, 一般通过url传参数方式传参)
- post: 一般应用于向服务器传递数据(向服务器传递的数据多, 获取服务器的数据少, 一般通过请求体的方式进行传参)->一般用于向服务器添加数据信息
- delete: 一般应用于删除服务器的指定信息(和get一致)
- put: 一般用于更新服务器的指定信息(和post一致)
- head: 一般用于获取响应头信息, 不获取响应体

> 总结:get和delete相似, post和put相似

### get和post请求方式的比较
- 1: 大小问题: get请求传参有大小限制, post理论上没有大小限制
> 原因: get请求是通过url进行传参的, 而每个浏览器对url的长度有 限制(谷歌8kb ie 2kb), 如果url过长, 浏览器会自动截取; post通过请求体传递参数, 理论上没有大小, 但是一般要求不要超过2mb
- 2: 缓存问题: get请求会出现缓存, post没有缓存问题
> 浏览器有记录, 如果两次get请求的地址一样, 会进行缓存处理, 第二次请求获取的内容和第一次一样, 但是一旦信息修改, 读取到的还是旧的信息, 所以不建议有缓存, 使用在url后面增加随机数, 保证每次请求的url地址信息不同, 防止get请求的缓存问题
- 3: 安全问题: get相对不安全, post相对安全
> get传参数通过url, post传参通过请求体, 安全是相对的, 没有绝对的安全, 因为url和请求体都能够获取

### http状态码
![http状态吗]()
> 状态码分类:
- 1xx: 1开头表示消息, 这类开头的状态码, 代表请求已经被接收,需要继续处理
- 2xx: 2开头表示成功, 这一类型的状态码，代表请求已成功被服务器接收、理解、并接受
- 3xx: 3开头表示重定向, 这类状态码代表需要客户端采取进一步的操作才能完成请求。
- 4xx: 4开头表示请求(客户端)错误, 这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。
- 5xx: 5开头表示服务器错误, 这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。

> 常见的状态码
- 200: 成功(2开头的都是表示请求成功了)
- 301: 永久重定向(http://www.360buy.com/)
- 302: 临时重定向(服务器负载均衡)
- 304: 客户端请求服务器返回的是缓存信息
- 400: 客户端传递给服务器的参数出现错误
- 401: 无权限访问
- 404: 访问地址不存在
- 500: 未知的服务器错误
- 503: 服务器超负荷

## ajax介绍
- Ajax: async javascript and xml异步的javascript和xml
- 客户端中的js方法 用来向服务器发送请求(还可以传递给服务器相关数据url, 请求体), 然后把服务器返回的内容获取到(ajax一般是运行在客户端的浏览器中)
### ajax四步
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
      大家好
</body>
<script>
    //1: 创建一个ajax对象(ie6低版本不兼容)
    var xhr = new XMLHttpRequest();

    /**
     * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
     * 请求方式: get/post/put/delete/head
     * 请求地址: url, 可以传参
     * 是否异步: true异步, false同步
     * */
    xhr.open('get', './data.txt', false);
    /**
     * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
     *
     * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
     *
     * UNSENT:0 未发送
     * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
     * HEADERS_RECEIVED:2 响应头信息已经接受
     * LOADING:3 响应体的内容正在服务器端进行准备处理
     * DONE:4 响应体的内容已经成功返回给客户端
     *
     * xhr.status: http响应状态码
     * 1开头: 消息
     * 2开头: 成功
     * 3开头: 重定向
     * 4开头: 客户端错误
     * 5开头: 服务器错误
     * */
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)){
            console.log(xhr.responseText);
        }
    };
    /**
     * 发送ajax请求
     * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
     * */
    xhr.send(null);
</script>
</html>
```

### 创建ajax对象封装
```js
//1: 创建一个ajax对象(ie6低版本不兼容)
var xhr = null;

/*if (window.XMLHttpRequest) {
 xhr = new XMLHttpRequest();
 /!**
 * 兼容ie低版本, 但是这样写不合理, 不合理原因是什么???如何解决??
 * 由于new ActiveXObject('Microsoft.XMLHTTP')程序直接报错, 根本无法判断
 * 解决方法: 使用try-catch
 * *!/
 } else if (new ActiveXObject('Microsoft.XMLHTTP')) {
 xhr = new ActiveXObject('Microsoft.XMLHTTP');
 } else if (new ActiveXObject('Msxml2.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml2.XMLHTTP');
 } else if (new ActiveXObject('Msxml3.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml3.XMLHTTP');
 }*/

//使用try-catch创建ajax对象
function createXHR() {
    try {
        xhr = new XMLHttpRequest();
    } catch (err) {
        try {
            xhr = new ActiveXObject('Microsoft.XMLHTTP');
        } catch (err) {
            try {
                xhr = new ActiveXObject('Msxml2.XMLHTTP');
            } catch (err) {
                xhr = new ActiveXObject('Msxml3.XMLHTTP');
            }
        }
    }
}

//创建ajax对象
var xhr = createXHR();

/**
 * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
 * 请求方式: get/post/put/delete/head
 * 请求地址: url, 可以传参
 * 是否异步: true异步, false同步
 * */
xhr.open('get', './data.txt', false);
/**
 * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
 *
 * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
 *
 * UNSENT:0 未发送
 * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
 * HEADERS_RECEIVED:2 响应头信息已经接受
 * LOADING:3 响应体的内容正在服务器端进行准备处理
 * DONE:4 响应体的内容已经成功返回给客户端
 *
 * xhr.status: http响应状态码
 * 1开头: 消息
 * 2开头: 成功
 * 3开头: 重定向
 * 4开头: 客户端错误
 * 5开头: 服务器错误
 * */
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)) {
        console.log(xhr.responseText);
    }
};
/**
 * 发送ajax请求
 * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
 * */
xhr.send(null);
```

> 上面代码try-catch重复嵌套, 代码不美观, 程序中多次调用createXHR方法每次调用都要进行从上到下的判断, 但是在程序中第一次调用的时候判断一次后, 以后浏览器类型就能够确定, 无需再次重复判断
- 惰性思想封装ajax对象创建

```js
//1: 创建一个ajax对象(ie6低版本不兼容)
var xhr = null;

/*if (window.XMLHttpRequest) {
 xhr = new XMLHttpRequest();
 /!**
 * 兼容ie低版本, 但是这样写不合理, 不合理原因是什么???如何解决??
 * 由于new ActiveXObject('Microsoft.XMLHTTP')程序直接报错, 根本无法判断
 * 解决方法: 使用try-catch
 * *!/
 } else if (new ActiveXObject('Microsoft.XMLHTTP')) {
 xhr = new ActiveXObject('Microsoft.XMLHTTP');
 } else if (new ActiveXObject('Msxml2.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml2.XMLHTTP');
 } else if (new ActiveXObject('Msxml3.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml3.XMLHTTP');
 }*/

/*
//使用try-catch创建ajax对象
function createXHR() {
    try {
        xhr = new XMLHttpRequest();
    } catch (err) {
        try {
            xhr = new ActiveXObject('Microsoft.XMLHTTP');
        } catch (err) {
            try {
                xhr = new ActiveXObject('Msxml2.XMLHTTP');
            } catch (err) {
                xhr = new ActiveXObject('Msxml3.XMLHTTP');
            }
        }
    }
}
*/

function createXHR(){
    var ary = [function () {
        return new XMLHttpRequest()
    }, function () {
        return new ActiveXObject('Microsoft.XMLHTTP');
    }, function () {
        return new ActiveXObject('Msxml2.XMLHTTP');
    },function () {
        return new ActiveXObject('Msxml3.XMLHTTP');
    }];
    var xhr = null;
    var flag = false;
    for (var i=0; i<ary.length; i++){
        var cur = ary[i];
        try {
            xhr = cur();//调用方法
            createXHR  = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
            flag = true;//找到创建ajax的方法
            break; //结束循环
        } catch (err){
            //报错, 继续执行后面的方法创建ajax对象
        }
    }
    if (!flag){ //没有找到适合当前浏览器创建ajax的方法
        throw errors('没有适合当前浏览器的创建ajax的方法');
    }
    return xhr;
}


//创建ajax对象
var xhr = createXHR();

/**
 * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
 * 请求方式: get/post/put/delete/head
 * 请求地址: url, 可以传参
 * 是否异步: true异步, false同步
 * */
xhr.open('get', './data.txt', false);
/**
 * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
 *
 * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
 *
 * UNSENT:0 未发送
 * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
 * HEADERS_RECEIVED:2 响应头信息已经接受
 * LOADING:3 响应体的内容正在服务器端进行准备处理
 * DONE:4 响应体的内容已经成功返回给客户端
 *
 * xhr.status: http响应状态码
 * 1开头: 消息
 * 2开头: 成功
 * 3开头: 重定向
 * 4开头: 客户端错误
 * 5开头: 服务器错误
 * */
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)) {
        console.log(xhr.responseText);
    }
};
/**
 * 发送ajax请求
 * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
 * */
xhr.send(null);

```

### ajax请求中的同步和异步(async/sync)

<!-- > 同步 -->
<!-- ![同步](img/3.png)

> 异步
![异步](img/4.png)

> 多线程并发
![多线程并发](img/5.png) -->

### js中的异步编程:
- 1: 定时器: 指定的时间后执行
- 2: 事件绑定: 指定的事件发生后触发绑定的事件执行
- 3: 回调函数: 主调函数中执行
- 4: ajax

> 定时器: 思考题
```js
/*//思考1: 执行结果??
    var count = 0;
    setTimeout(function () {
        count++;
        console.log(count);
    }, 1000);
    console.log(count);*/


    /*//思考2: 执行结果??
    var count = 0;
    setTimeout(function () {
        count++;
        console.log(count);
    }, 0); //所有的浏览器都有一个最小等待事件(谷歌5~6ms)
    console.log(count);*/

    /*//思考3: 执行结果??
    var count = 0;
    setTimeout(function () {
        count++;
        console.log(count);
    }, 1000);//1000变成0??
    console.log(count);
    while (1){
        //程序执行到这个死循环后一直停在这里,后续的操作都没有办法进行, 因为同一时刻只能做一件事
    }*/

    /*//思考4: 执行结果??
    setTimeout(function () {
        console.log('A');
    }, 100);

    setTimeout(function () {
        console.log('B');
    }, 10);
    //多个定时器, 按照道事件大小进行排序, 时间少的先执行, 时间多的后执行, 和定时器代码先后顺序无关
    var i = 0;
    while (i<1000000000){
        i++;
    }*/
```

> ajax中的同步
- 思考题: 打印几次? 输出结果是什么
- 实例一:
```js
var xhr = new XMLHttpRequest();

    /**
     * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
     * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
     * */
    xhr.open('get', 'data.txt', false);

    xhr.onreadystatechange = function () {
        console.log(xhr.readyState);
    };

    xhr.send(null);  //只有send之后ajax任务才开始执行(向服务器发送请求任务)
```

- 实例二:
```js
var xhr = new XMLHttpRequest();

    /**
     * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
     * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
     * */
    xhr.open('get', 'data.txt', false);

    xhr.send(null);  //只有send之后ajax任务才开始执行(向服务器发送请求任务)

    xhr.onreadystatechange = function () {
        console.log(xhr.readyState);
    };

```

> ajax中的异步
- 思考题: 打印几次? 输出结果是什么??
- 实例一:
```js
var xhr = new XMLHttpRequest();

    /**
     * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
     * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
     * */
    xhr.open('get', 'data.txt', true);

    xhr.onreadystatechange = function () {
        console.log(xhr.readyState);
    };

    xhr.send(null);  //只有send之后ajax任务才开始执行(向服务器发送请求任务)
```

- 实例二:
```js
  var xhr = new XMLHttpRequest();

    /**
     * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
     * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
     * */
    xhr.open('get', 'data.txt', true);

    xhr.send(null);  //只有send之后ajax任务才开始执行(向服务器发送请求任务)

    xhr.onreadystatechange = function () {
        console.log(xhr.readyState);
    };
```

### readyState状态码为2的时候获取响应头信息
```js
var xhr = new XMLHttpRequest();

    /**
     * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
     * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
     * */
    xhr.open('head', 'data.txt', true);

    xhr.send(null);  //只有send之后ajax任务才开始执行(向服务器发送请求任务)

    xhr.onreadystatechange = function () {
        /**
         * readyState状态为2, 响应头信息已经获取到
         * 有时候我们不需要请求体的内容, 只需要获取响应头的信息的时候, 这时候为了节约时间, 可以在状态为2的时候直接获取响应头, 但是只能是异步请求才可以, 因为同步的话只有状态为4才能够开始获取状态
         * */
        if (xhr.readyState == 2){
            console.log(new Date(xhr.getResponseHeader('Date')));
        }
        //head请求只能获取响应头, 不能获取响应体
        if (xhr.readyState == 4){
            console.log(xhr.responseText);
        }
    };
```

### ajax的封装
```js
(function () {
    function createXHR() {
        var ary = [function () {
            return new XMLHttpRequest()
        }, function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }];
        var xhr = null;
        var flag = false;
        for (var i = 0; i < ary.length; i++) {
            var cur = ary[i];
            try {
                xhr = cur();//调用方法
                createXHR = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
                flag = true;//找到创建ajax的方法
                break; //结束循环
            } catch (err) {
                //报错, 继续执行后面的方法创建ajax对象
            }
        }
        if (!flag) { //没有找到适合当前浏览器创建ajax的方法
            throw errors('没有适合当前浏览器的创建ajax的方法');
        }
        return xhr;
    }

//ajax实现ajax请求的公共方法
    function ajax(options) {
        //把需要使用的参数值指定默认的初始值, 一旦没有传递的话可以使用默认值进行赋值
        var _default = {
            type: 'get', //请求方式
            url: null,  //请求url地址
            async: true,  //是否异步
            data: null,  //请求体数据
            dataType: 'json',//设置请求回来的数据格式'json'就是将请求回来的数据转换成json对象 'txt'就是请求回来的数据为字符串
            success: null   //请求成功时的回调
        };

        //使用实参替换默认值
        for (var attr in options) {  //遍历options
            if (options.hasOwnProperty(attr)) { //获取私有属性
                _default[attr] = options[attr];    //用options替换_default
            }
        }


        //解决get请求的缓存问题
        if (_default.type == 'get'){
            //如果url中已经包含'?'则在原有基础上增加&_=随机数, 否则url末尾增加?_=随机数, 解决get请求的缓存问题
            _default.url += (((_default.url.indexOf('?')>=0)?' &_=': '?_=')+Math.random());
        }


        //1: 实例化ajax对象
        var xhr = createXHR();

        xhr.open(_default.type, _default.url, _default.async);

        xhr.onreadystatechange = function () {
            if (/^2\d{2}$/.test(xhr.status)) {
                //状态码为4的时候
                if (xhr.readyState == 4) {
                    var val = xhr.responseText;
                    //如果传递的dataType类型是json, 说明获取的是json对象
                    if (_default.dataType == 'json') {
                        val = 'JSON' in window ? JSON.parse(val) : eval('(' + val + ')');
                    }
                    _default.success && _default.success.call(xhr, val);
                }
            }
        };
        //发送ajax请求, 参数是请求主体信息
        xhr.send(_default.data);
    }

    //将ajax变成全局属性
    window.ajax = ajax;
})();
```

## CRM客户端管理系统

## jsonp跨域
> jsonp和ajax相同, 都是客户端向服务器发送请求, 给服务器发送请求传递数据, 然后同服务器获取数据
> jsonp和ajax比较
- ajax属于同源策略
- jsonp属于非同源策略(跨域请求)
> 当前页面的url地址(webstorm在预览页面的时候会默认的创建一个本地虚拟的服务, 端口号是63342)

http://localhost:63342/备课node/1.node基础/1.html

http://localhost:63342/备课node/node/1.node基础/data.txt

> 练习: 通过ajax请求
- 当前路径下的data.json文件内容
- 通过ajax请求百度https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a
- 通过ajax请求腾讯http://matchweb.sports.qq.com/kbs/calendar?columnId=100000
- 找出每个请求的url地址和当前html文件的url地址进行比较
```
var xhr = new XMLHttpRequest();
    //ajax支持同源请求
    //xhr.open('get', 'http://localhost:63342/%E5%A4%87%E8%AF%BE/node/1.%20node%E5%9F%BA%E7%A1%80/data.txt', true);
    //ajax不支持非同源请求->XMLHttpRequest cannot load https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a. No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:63342' is therefore not allowed access.
   // xhr.open('get', 'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a', true);
    xhr.open('get', 'http://matchweb.sports.qq.com/kbs/calendar?columnId=100000', true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)){
            console.log(xhr.responseText);
        }
    };
    xhr.send(null);
```

> 同源和非同源需要比较的内容: 三者必须完全相同才能算同源
- 协议名
- 域名
- 端口号

### jsonp的原理
> jsonp实现跨域请求是通过script标签, 不受非同源的影响, 通过script的src获取非同源url下的信息
> jsonp实现跨域请求的步骤
- 1: 我们首先把需要请求的数据url地址, 赋值给script标签的src属性
- 2: 把当前页面中的某一个函数名通过url传参的方式添加到url中传递给服务器进行请求->例如: url?callback=fn
- 3: 服务器接收到客户端的请求后, 需要进行特殊的处理, 把你传递进来的函数名和它需要传递给你的数据拼接成一个字符串, 返回给客户端(例如: 客户端传递的函数名为fn, 返回的数据就放在fn函数中作为实参进行传递, 'fn(数据)');
- 4: 最后服务器把准备好的数据通过http协议返回给客户端, 返回的内容其实就是fn方法的调用, 传递的数据就是fn方法的实参

> jsonp跨域请求腾讯看比赛客户端
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>jsonp跨域请求</title>
</head>
<body>

</body>
<script>
    function fn(data){ //fn中data就是服务器传递给客户端的数据
        console.log(data);
    }
</script>
<!--通过script标签实现跨域请求, 将当前html文件中的fn方法名, 通过url传给服务器, 服务器返回的就是fn方法的调用-->
<script src="http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&callback=fn"></script>
</html>
```

> jsonp跨域请求自定义服务端
- 练习: 实现静态资源文件的请求
> 服务端
```js
var http = require('http');
var url = require('url');
var fs = require('fs');
//创建服务
var server = http.createServer(function (req, res) {
    var urlObj = url.parse(req.url, true); //解析url
    var pathname = urlObj.pathname; //请求路径
    var query = urlObj.query; //请求参数

    var reg = /\.(HTML|CSS|JS|TXT|JSON|ICO)/i;
    //静态资源文件处理
    if (reg.test(pathname)){ //如果请求的文件包含正则中的内容
        var suffix = reg.exec(pathname)[1].toUpperCase();//获取请求文件的后缀名, 转换成大写
        var suffixMIME = 'text/html';//默认是html文件

        switch (suffix){ //通过检索的pathname的后缀名, 获取对应的MIME类型
            case 'HTML': {
                suffixMIME = 'text/HTML';
            } break;
            case 'CSS': {
                suffixMIME = 'text/css';
            } break;
            case 'JS': {
                suffixMIME = 'text/application';
            } break;
            case 'JSON': {
                suffixMIME = 'application/json';
            } break;
            case 'TXT': {
                suffixMIME = 'text/plain';
            } break;
        }

        //如果请求的是/index.html文件
        try {
            var con = fs.readFileSync('.' + pathname, 'utf8');  //读取index.html内容
            res.writeHead(200, {'content-type':suffixMIME+';charset=utf8'});
            res.end(con);//返回信息给客户端
        }catch (err){
            res.writeHead(404, {'content-type': "text/plain;charset=utf8"});
            res.end('request file is not find');//返回信息给客户端
        }
    }

    //jsonp请求处理
    if (pathname == '/getAll'){
        var callback = query['callback'];//获取url中的回调函数方法名
        //准备数据
        var conFile = fs.readFileSync('./custom.json', 'utf8');
        //返回给客户端
        res.writeHead(200, {'content-type':'text/javascript;charset=utf8'}); //按照js代码解析返回的内容, 执行返回的回调函数, 将内容作为实参进行传递
        res.end(callback+'('+conFile+')');//方法名(数据)

    }
});

//监听端口
server.listen(8080, function () {
    console.log('server is success, listening 8080...');
});
```
> 客户端
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ajax四步</title>
</head>
<body>

</body>
<script>
    //2: 创建一个自定义函数
    function fn(data) {
        //4，5：等待服务器返回数据
        console.log(data);
    }
</script>
<!--1: 将非同源的url地址赋值给script标签的src属性-->
<!--3: 将自定义函数名拼接到url末尾-->
<script src="http://localhost:8080/getAll?callback=fn"></script>
```

### jquery中的ajax
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>jquery中的jsonp</title>
</head>
<body>

</body>
<script src="./public/jquery.js"></script>
<script>
    /**
     * jquery中的ajax
     * jquery中的ajax方法是定义在jquery自身的一个方法，直接使用$调用即可
     * 参数：ajax请求的相关配置
     * */
    $.ajax({
        type: 'get', //请求类型
        url: 'data.txt',  //请求url地址
        async: true,     //是否同步
        data: null,   //客户端通过请求体传递的数据
        cache: false, //是否需要缓存(url末尾增加?_随机数), 默认有缓存
        dataType: 'json',//请求数据转换成json对象
        timeout: 3000, //超时时间设置，超过该时间后数据没有请求回来，调用error回调
        success: function (data) { //请求成功时候的回调，参数data是请求回来的数据
            console.log(data); //请求回来的数据默认是string类型
        },
        error: function (err) {//请求数据失败时候的回调
            console.log(err);
        }
    });

</script>
</html>
```

### jquery中的jsonp跨域请求
> 跨域请求地址: http://matchweb.sports.qq.com/kbs/calendar?columnId=100000
> jquery转换后地址： http://matchweb.sports.qq.com/kbs/calendar?columnId=100000&callback=jQuery31106322290808849953_1477278795125&_=1477278795126 自动在末尾追加callback方法名， 是一个jQuery随机数, 自动追加随机数清除缓存, jsonp都是get请求

> jsonp简单用法
```
/**
     * jquery中的ajax
     * jquery中的ajax方法是定义在jquery自身的一个方法，直接使用$调用即可
     * 参数：ajax请求的相关配置
     * */
    $.ajax({
        url: 'http://matchweb.sports.qq.com/kbs/calendar?columnId=100000',  //请求url地址
        dataType: 'jsonp',//jsonp跨域请求
        success: function (data) { //请求成功时候的回调，参数data是请求回来的数据
            console.log(data); //请求回来的数据默认是string类型
        }
    });
```
> 修改回调函数名和回调函数属性名(jsonpCallback和jsonp)
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>jquery中的jsonp</title>
</head>
<body>

</body>
<script src="./public/jquery.js"></script>
<script>
    /**
     * jquery中的ajax
     * jquery中的ajax方法是定义在jquery自身的一个方法，直接使用$调用即可
     * 参数：ajax请求的相关配置
     * */
    $.ajax({
        url: 'http://matchweb.sports.qq.com/kbs/calendar?columnId=100000',  //请求url地址
        dataType: 'jsonp',//jsonp跨域请求
        jsonpCallback: 'fn',//指定回调函数的方法名， 不使用jquery自动指定(callback='fn')
        jsonp:'cb',//改变回调函数的方法名, 将callback变成cb(cb=fn)
        success: function (data) { //请求成功时候的回调，参数data是请求回来的数据
            console.log(data); //请求回来的数据默认是string类型
        }
    });

</script>
</html>
```

### jquery中的jsonp跨域请求实战(百度下拉搜索)
> 百度搜索接口： https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd=a&cb=jQuery110205029368403378756_1477280723821&_=1477280723824
> 回调函数属性名：jsonp: 'cb'
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>baidu</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
        html, body{
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-size: 14px;
            color: #000;
            font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
        }
        ul, li{
            list-style: none;
        }
        input{
            outline: none;
        }
        .box{
            width: 300px;
            margin: 50px auto;
        }
        .box input{
            width: 280px;
            height: 30px;
            padding: 0 10px;
            border: 1px solid lightgreen;
        }
        .box ul{
            width: 100%;
            border: 1px solid lightgreen;
            border-top: none;
        }
        .box ul li{
            padding: 0 10px;
            height: 25px;
            line-height: 25px;
        }
    </style>
</head>
<body>
    <div class="box">
        <input type="text" id="searchInp">
        <ul id="searchList">
            <!--<li>百知教育java</li>
            <li>百知教育大数据</li>
            <li>百知教育前端</li>
            <li>百知教育node</li>-->
        </ul>
    </div>
</body>
<script src="public/jquery.js"></script>
<script>
    var searchModule = (function () {
        var $searchInp = $('#searchInp');
        var $searchList = $('#searchList');

        function bindHTML(){
            var wd = $searchInp.val(); //获取搜索框中的内容
            $.ajax({
                url:'https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su?wd='+wd,
                dataType: 'jsonp',
                jsonp: 'cb',
                success: function (data) {
                    var str = '';
                    $.each(data.s, function (index, item) { //遍历数据源
                        if (index<=3){  //取前四条
                            str += '<li>'+item+'</li>'; //绑定数据
                        }
                    });
                    //设置结果列表
                    $searchList.html(str).stop().slideDown(100);
                }
            });
        }
        //向百度服务器发送jsonp请求，把请求回来的数据绑定在页面上
        function init(){
            $searchInp.on('keyup focus', function () {
                var val = $(this).val();
                if (val.length > 0){
                    bindHTML();
                    return;
                }
                $searchList.stop().slideUp(100);
            });

            //当点击展示框中的li的时候，把li的内容显示到搜索框中，并且把搜索列表隐藏
            $searchList.on('click', function (ev) {
                var tar = ev.target;
                var tarTag = tar.tagName.toUpperCase();
                var $tar = $(tar);
                if (tarTag == 'LI'){
                    $searchInp.val($tar.html());
                    $searchList.stop().slideUp(100);
                }
            })
        }

        return {
            init: init
        }
    })();
    searchModule.init();
</script>
</html>
```

> 练习：编写百度的后台逻辑代码实现前后端jsonp跨域请求的交互(返回的数据随意)


## 项目一：ajax分页
### 接口的制定
> 1: 获取某页所有学员信息
```
type: get
url: '/getList'
参数: url传参, ?page=1 告诉服务器需要获取第一页的信息
返回值:
{
    "code": 0,    //状态码 0成功1失败
    "msg":"获取数据成功", //状态码的描述
    "total": 10, // 总页数(一共有多少页数据)
    "data": [   //返回一个数组， 数组中是第n页的所有学员信息
        {
            "num":1,
            "name":"chenchao",
            "sex":0 //0男1女
            "score": 100
        },
        ......
    ]
}
```
> 2: 获取指定某个学员信息
```
 type: get
 url: '/getInfo'
 参数: url传参, ?id=1 获取id为1的学员信息
 返回值:
 {
     "code": 0,    //状态码 0成功1失败
     "msg":"获取数据成功", //状态码的描述
     "data": {  //返回一个对象
             "num":1,
             "name":"chenchao",
             "sex":0 //0男1女
             "score": 100
         }
 }
```

### 获取假数据代码
```
//制造假数据

var fs = require('fs');
var ary = [];

function getRandomNum(m, n){  //获取m~n之间的随机数
    return Math.round((n-m)*Math.random()+m);
}

var str = '吉林省地方路径肯定是疯了艰苦奋斗卡勒季斯的风景电风扇对粉丝的疯狂时刻据了解分手的借口来打发时间看非极乐世界开放式的借口来大煞风景了圣诞节来大煞风景发动机来说';
for (var i=1; i<=98; i++){
    var obj = {};
    obj.id = i;
    obj.name = str[getRandomNum(0, str.length-1)]+str[getRandomNum(0, str.length-1)];
    obj.sex = getRandomNum(0, 1);
    obj.score = getRandomNum(60, 100);
    ary.push(obj);
}
fs.writeFileSync('./data.json', JSON.stringify(ary), 'utf8');



```

### 服务器端代码server.js
```
var http = require('http');
var url = require('url');
var fs = require('fs');

var server = http.createServer(function (req, res) {
    var objUrl = url.parse(req.url, true);
    var pathname = objUrl.pathname;
    var query = objUrl.query;

    var reg = /\.(HTML|CSS|JS|JSON|ICO|HTML)$/i;
    //静态之间文件的处理
    if (reg.test(pathname)) {
        var suffix = reg.exec(pathname)[1].toUpperCase();
        var suffixMIME = 'text/plain';

        switch (suffix) {
            case 'HTML':
            {
                suffixMIME = 'text/html';
            }
                break;
            case 'JS':
            {
                suffixMIME = 'text/application';
            }
                break;
            case 'CSS':
            {
                suffixMIME = 'text/css';
            }
                break;
            case 'TXT':
            {
                suffixMIME = 'text/plain';
            }
                break;
            case 'JSON':
            {
                suffixMIME = 'application/json';
            }
                break;
        }
        try {
            var conFile = fs.readFileSync('.' + pathname, 'utf8');
            res.writeHead(200, {'content-type': suffixMIME + ';charset=utf8'});
            res.end(conFile);
        } catch (err) {
            res.writeHead(404, {'content-type': 'text/plain;charset=utf8'});
            res.end();
        }
        return;
    }


    //客户端请求接口的处理
    //获取所有学生信息
    function getAllStudentInfo() {
        var ary = fs.readFileSync('./data/data.json', 'utf8');
        (!ary) && (ary = '[]'); //防止json转换的时候报错
        return JSON.parse(ary); //获取所有学生信息
    }

    //通过page获取指定页的学生信息
    function getStudentFromPage(page, allStudent) {
        var begin = (page - 1) * 10;
        var end = page * 10 - 1 > allStudent.length - 1 ? allStudent.length - 1 : page * 10 - 1;//如果获取最后一页信息可能会越界，如果越界取最大值
        var ary = [];  //保存符合信息的数组
        for (var i = begin; i <= end; i++) {
            ary.push(allStudent[i]); //将符合信息的数据保存起来
        }
        return ary;  //返回符合信息的数组
    }

    function getStudentInfoFromId(studentId, allStudent){
        for (var i=0; i<allStudent.length; i++){ //遍历所有学生信息
            if (allStudent[i].id == studentId){  //找到id匹配的学生信息
                return allStudent[i];  //返回匹配的学生信息
            }
        }
        return null;  //没找到返回空
    }

    //请求第page页学生信息
    if (pathname == '/getList') {
        /**
         * 1: 获取请求参数中的第几页
         * 2: 获取所有用户信息
         * 3: 遍历所有用户信息，找到用户需要的第几页中所有信息
         * 4: 将获取的信息进行拼接，返回给客户端
         * */
        var page = parseInt(query.page); //获取请求参数中的页数
        var allStudent = getAllStudentInfo();//获取所有学生信息
        var ary = getStudentFromPage(page, allStudent);//获取符合要求的数据信息
        var result = {};
        result.code = ary.length ? 0 : 1;
        result.msg = ary.length ? '请求信息成功' : '请求信息失败';
        result.total = Math.ceil(allStudent.length/10); //总页数
        result.data = ary;

        res.writeHead(200, {'content-type':'application/json;charset=utf8'});
        res.end(JSON.stringify(result));
        return;
    }

    //请求指定id号学生信息
    if (pathname == '/getInfo'){
        /**
         * 1: 获取指定学生的id信息
         * 2: 获取所有学生信息
         * 3: 找出id号匹配的学生信息
         * 4: 根据要求拼接返回信息
         * */
        var studentId = parseInt(query.id);//获取学生id
        var allStudent = getAllStudentInfo();//获取所有学生信息
        var student = getStudentInfoFromId(studentId, allStudent);//找到id匹配的学生信息
        var result = {};
        result.code = student?0:1;
        result.msg = student?'请求学生信息成功':'请求学生信息失败';
        result.data = student;

        res.writeHead(200, {'content-type':'application/json;charset=utf8'});
        res.end(JSON.stringify(result));
        return;
    }
});

server.listen(9999);
```

### ajax.js代码
```
(function () {
    function createXHR() {
        var ary = [function () {
            return new XMLHttpRequest()
        }, function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }];
        var xhr = null;
        var flag = false;
        for (var i = 0; i < ary.length; i++) {
            var cur = ary[i];
            try {
                xhr = cur();//调用方法
                createXHR = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
                flag = true;//找到创建ajax的方法
                break; //结束循环
            } catch (err) {
                //报错, 继续执行后面的方法创建ajax对象
            }
        }
        if (!flag) { //没有找到适合当前浏览器创建ajax的方法
            throw errors('没有适合当前浏览器的创建ajax的方法');
        }
        return xhr;
    }

//ajax实现ajax请求的公共方法
    function ajax(options) {
        //把需要使用的参数值指定默认的初始值, 一旦没有传递的话可以使用默认值进行赋值
        var _default = {
            type: 'get', //请求方式
            url: null,  //请求url地址
            async: true,  //是否异步
            data: null,  //请求体数据
            dataType: 'json',//设置请求回来的数据格式'json'就是将请求回来的数据转换成json对象 'txt'就是请求回来的数据为字符串
            success: null   //请求成功时的回调
        };

        //使用实参替换默认值
        for (var attr in options) {  //遍历options
            if (options.hasOwnProperty(attr)) { //获取私有属性
                _default[attr] = options[attr];    //用options替换_default
            }
        }


        //解决get请求的缓存问题
        if (_default.type == 'get'){
            //如果url中已经包含'?'则在原有基础上增加&_=随机数, 否则url末尾增加?_=随机数, 解决get请求的缓存问题
            _default.url += (((_default.url.indexOf('?')>=0)?' &_=': '?_=')+Math.random());
        }


        //1: 实例化ajax对象
        var xhr = createXHR();

        xhr.open(_default.type, _default.url, _default.async);

        xhr.onreadystatechange = function () {
            if (/^2\d{2}$/.test(xhr.status)) {
                //状态码为4的时候
                if (xhr.readyState == 4) {
                    var val = xhr.responseText;
                    //如果传递的dataType类型是json, 说明获取的是json对象
                    if (_default.dataType == 'json') {
                        val = 'JSON' in window ? JSON.parse(val) : eval('(' + val + ')');
                    }
                    _default.success && _default.success.call(xhr, val);
                }
            }
        };
        //发送ajax请求, 参数是请求主体信息
        xhr.send(_default.data);
    }

    //将ajax变成全局属性
    window.ajax = ajax;
})();
```

### 客户端代码
> 首页index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
    <div class="box">
        <h2 class="header">
            <span>学号</span>
            <span>姓名</span>
            <span>性别</span>
            <span>成绩</span>
        </h2>
        <ul class="studentList" id="studentList">
            <!--<li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>
            <li>
                <span>1</span>
                <span>陈超</span>
                <span>男</span>
                <span>100</span>
            </li>-->
        </ul>
        <div class="page" id="pageControl">
            <span>首页</span>
            <span>上一页</span>
            <ul class="pageList" id="pageList">
               <!-- <li class="select">1</li>
                <li>2</li>
                <li>3</li>
                <li>4</li>
                <li>5</li>-->
            </ul>
            <span>下一页</span>
            <span>尾页</span>
            <input type="text" id="pageNum">
        </div>
    </div>
</body>
<script src="js/ajax.js"></script>
<script src="js/index.js"></script>
</html>
```
> 首页index.css
```
* {
    margin: 0;
    padding: 0;
}

html, body {
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    font-size: 14px;
    color: #000;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
ul, li{
    list-style: none;
}
input{
    outline: none;
}
.box{
    width: 800px;
    margin: 20px auto;
    border: 2px solid lightgreen;
    padding: 20px;
    overflow: hidden;
}
.box h2{
    width: 100%;
    height: 40px;
    background: lightblue;
    border-radius: 5px;
}
.box ul{
    margin-bottom: 10px;
    height: 400px;
}
.box h2 span, .box .studentList li span{
    display: block;
    float: left;
    height: 40px;
    line-height: 40px;
    width: 25%;
    text-align: center;
}
.studentList li{
    width: 100%;
    height: 40px;
    cursor: pointer;
}
.box .studentList li span{
    font-size: 15px;
}
.box .studentList li:nth-child(even){
    background: lightyellow;
}
.box .studentList li:hover{
    background: lightgreen;
}

.page{
    float: right;
    height: 30px;
    margin-top: 10px;
}
.page span,.page ul, .page ul li, .page input{
    float: left;
}
.page span{
    width: 50px;
    height: 30px;
    line-height: 30px;
    border-radius: 5px;
    margin: 0 2px;
    background: lightgoldenrodyellow;
    text-align: center;
    border: 1px solid lightblue;
    cursor: pointer;
}
.page ul li{
    width: 30px;
    height: 30px;
    text-align: center;
    line-height: 30px;
    margin: 0 1px;
    border: 1px solid lightblue;
    border-radius: 2px;
    cursor: pointer;
}
.page ul li.select{
    background: lightcoral;
}
.page input{
    width: 30px;
    height: 30px;
    border-radius: 5px;
    padding: 0 10px;
    border: 1px solid lightblue;
}

```

> 首页index.js
```
var pageModule = (function () {
    var studentList = document.getElementById('studentList');
    var pageControl = document.getElementById('pageControl');
    var pageList = document.getElementById('pageList');
    var pageNum = document.getElementById('pageNum');
    //设置当前页和总页数
    var page = 1;
    var total = 0;

    //事件数据的绑定
    function bindHTML(data) {
        if (data && data.code == 0) {
            //设置pageNum中显示当前页码
            pageNum.value = page;

            var str = '';
            //绑定学生列表区域
            data.data.forEach(function (student, index) {
                str += '<li studentId="'+student.id+'"> <span>' + student.id + '</span> <span>' + student.name + '</span> <span>' + (student.sex ? '女' : '男') + '</span> <span>' + student.score + '</span> </li>';
            });
            studentList.innerHTML = str;

            //绑定页码区域
            str = '';
            total = parseInt(data.total);//获取总页数
            for (var i = 1; i <= total; i++) {
                str += '<li class="' + (page == i ? 'select' : '') + '">' + i + '</li>'
            }
            pageList.innerHTML = str;
        }
    }

    //通过事件委托实现事件的绑定
    function bindEvent() {
        //页面控制区域
        pageControl.onclick = function (ev) {
            ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            var targetTagName = target.tagName.toUpperCase();
            if (targetTagName == 'SPAN') {
                if (target.innerHTML == '首页') {
                    if (page == 1) {
                        return;
                    }
                    page = 1;
                }
                if (target.innerHTML == '上一页') {
                    if (page == 1) {
                        return;
                    }
                    page--;
                }
                if (target.innerHTML == '下一页') {
                    if (page == total) {
                        return;
                    }
                    page++;
                }
                if (target.innerHTML == '尾页') {
                    if (page == total) {
                        return;
                    }
                    page = total;
                }
            }

            if (targetTagName == 'LI') {
                if (page == parseInt(target.innerHTML)) {
                    return;
                }
                page = parseInt(target.innerHTML);//获取li上的页面
            }

            if (targetTagName == 'INPUT') {
                return;
            }

            //从新获取数据，绑定新数据
            sendAjax();
        };
        //页码区域控制
        pageNum.onkeyup = function (ev) {
            ev = ev || window.event;
            if (ev.keyCode == 13) { //enter
                var val = this.value;
                if (isNaN(val)) {//非有效数字不处理
                    this.value = page;
                } else {   //有效数字
                    if (val < 1) {     //小于最小页
                        this.value = 1;
                        page = 1;
                    } else if (val > total) {//大于最大页
                        this.value = total;
                        page = total;
                    } else {
                        page = val;
                    }
                }
                //从新获取数据，绑定新数据
                sendAjax();
            }
        };
        //用户列表区域
        studentList.onclick = function (ev) {
            ev = ev || window.event;
            var target = ev.target || ev.srcElement;
            var targetTagName = target.parentNode.tagName.toUpperCase();
            console.log(targetTagName)
            if (targetTagName == 'LI'){
                //window.location.href = 'detail.html';
                window.open('detail.html?id='+target.parentNode.getAttribute('studentId'));
            }
        }
    }

    function sendAjax() {
        ajax({
            type: 'get',
            url: '/getList?page=' + page,
            async: true,
            dataType: 'json',
            data: null,
            success: bindHTML
        });
    }

    function init() {
        sendAjax();
        bindEvent();
    }

    return {
        init: init
    }

})();
pageModule.init();
```

> 详情页detail.html代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/detail.css">
</head>
<body>
    <div class="box">
        <h2 class="header">
            <span>学号</span>
            <span>姓名</span>
            <span>性别</span>
            <span>成绩</span>
        </h2>
        <div class="content" id="content">
           <!-- <span>1</span>
            <span>陈超</span>
            <span>男</span>
            <span>100</span>-->
        </div>
    </div>
</body>
<script src="js/ajax.js"></script>
<script src="js/detail.js"></script>
</html>
```
> 详情页detail.css代码
```
* {
    margin: 0;
    padding: 0;
}

html, body {
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    font-size: 14px;
    color: #000;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}
.box{
    width: 400px;
    margin: 100px auto;
    border: 3px solid lightblue;
    border-radius: 5px;
    padding: 20px;
}
h2, .content{
    width: 400px;
    height: 50px;
    line-height: 50px;
}
h2{
    background: lightgreen;
}
h2 span, .content span{
    width: 25%;
    float: left;
    text-align: center;
}
.content span{
    font-size: 20px;
}
```
> 详情页detail.js代码
```
function queryParamsUrl(url) {
    var obj = {};
    var reg = /([^=?#&]+)=([^=?#&]+)/g;
    url.replace(reg, function () {
        var key = arguments[1];
        var value = arguments[2];
        obj[key] = value;
    });
    return obj;
}
var detailModule = (function () {
    var url = window.location.href;//获取当前url路径
    var urlObj = queryParamsUrl(url); //获取url中的参数
    var studentId = urlObj.id; //获取url中用户id号

    var content = document.getElementById('content');

    function bindHTML(data){
        var str = '';
        for (var attr in data.data){
            str+='<span>'+data.data[attr]+'</span>'
        }
        content.innerHTML = str;
    }

    function init(){
        ajax({
            type:'get',
            url:'/getInfo?id='+studentId,
            async: true,
            data: null,
            dataType: 'json',
            success: bindHTML
        });
    }
    return {
        init: init
    }
})();
detailModule.init();

```

## CRM客户管理系统
### API接口文件
- 获取所有客户信息
```
type: get
URL: '/getAllUserInfo'
url参数：无
请求体参数: 无
返回：返回所有用户的信息
{
    "code": 0 //0成功，1失败
    "msg": "获取所有用户信息成功" //描述信息
    "data": [  //data对应的是一个数组， 里面保存的是所有用户
        {"id":1, name":"chenchao", "age":18, "phone":"111", "addr":"北京"},
        ......
    ]
}
```
- 获取指定某个各户的信息
```
type: get
URL: '/getUserInfo'
url参数：?id=1 //将用户的id传递给服务器
请求体参数：无
返回：返回id号对应的客户信息
{
   "code": 0 //0成功，1失败
   "msg": "获取指定用户信息成功" //描述信息
   "data": {"id":1, name":"chenchao", "age":18, "phone":"111", "addr":"北京"}  //data对应的是一个对象， 里面保存的是指定某个用户信息
}
```
- 增加客户信息
```
type: post
URL: '/addUserInfo'
url参数: 无
请求体参数：{name":"chenchao", "age":18, "phone":"111", "addr":"北京"}
返回：返回请求成功失败的描述信息
{
   "code": 0 //0成功，1失败
   "msg": "添加用户信息成功" //描述信息
}

注意：传递用户信息的时候客户端没有指定id值，该id值在服务器端进行指定
```
- 修改客户信息
```
type: post
URL: '/updateUserInfo'
url参数：无
请求体参数：{id:1, name":"chenchao", "age":18, "phone":"111", "addr":"北京"}  //修改后的用户信息
返回：返回修改成功的描述信息
{
    "code": 0 //0成功，1失败
    "msg": "修改用户信息成功" //描述信息
}
```
- 删除客户信息
```
 type: get
 URL: '/removeUserInfo'
 url参数：?id=1 //删除id号为1的客户信息
 请求体参数：无
 返回：返回修改成功的描述信息
 {
     "code": 0 //0成功，1失败
     "msg": "删除用户信息成功" //描述信息
 }
```

### 服务端server.js代码
```
var http = require('http');
var url = require('url');
var fs = require('fs');

var server = http.createServer(function (req, res) {
    var objUrl = url.parse(req.url, true);
    var pathname = objUrl.pathname;
    var query = objUrl.query;

    //静态资源文件处理
    var reg = /\.(HTML|CSS|JS|JSON|TXT|ICO)/i;
    if (reg.test(pathname)) {
        var suffix = reg.exec(pathname)[1].toUpperCase();
        var suffixMIME = 'text/plain';
        switch (suffix) {
            case 'HTML':
            {
                suffixMIME = 'text/HTML';
            }
                break;
            case 'CSS':
            {
                suffixMIME = 'text/css';
            }
                break;
            case 'js':
            {
                suffixMIME = 'text/application';
            }
                break;
            case 'txt':
            {
                suffixMIME = 'text/plain';
            }
                break;
            case 'json':
            {
                suffixMIME = 'application/json';
            }
                break;
        }
        try {
            var conFile = fs.readFileSync('.' + pathname, 'utf8');
            res.writeHead(200, {'content-type': suffixMIME + ';charset=utf8'})
            res.end(conFile);
        } catch (err) {
            res.writeHead(404, {'content-type': 'text/plain;charset=utf8'})
            res.end();
        }
        return;
    }

    //处理客户端请求信息


    function getAllUserInfo() {
        var allUserInfo = null;
        allUserInfo = fs.readFileSync('./data/allUserInfo.json', 'utf8');
        (!allUserInfo) && (allUserInfo = "[]");//如果为空，设置成空数组字符串(因为如果文件没有内容返回的是''空字符串，使用JSON.parse转换会报错)
        return JSON.parse(allUserInfo);
    }

    function getUserInfoFromId(allUserInfo, userId) {
        for (var i = 0; i < allUserInfo.length; i++) {  //遍历所有用户信息
            if (allUserInfo[i].id == userId) { //找到id相同的用户信息
                return allUserInfo[i]; //找到返回用户信息
            }
        }
        return null;//没找到返回null
    }

    function updateUserFromUser(allUserInfo, updateUser){
        for (var i=0; i<allUserInfo.length; i++){//遍历所有用户信息
            if (allUserInfo[i].id == updateUser.id){//找到更新的用户信息
                allUserInfo[i] = updateUser; //更新用户信息
                return true;
            }
        }
        return false;
    }

    function removeUserFromId(allUserInfo, userId){
        for (var i=0; i<allUserInfo.length; i++){//遍历所有用户信息
            if (allUserInfo[i].id == userId){//找到删除的用户信息
                allUserInfo.splice(i, 1); //删除指定用户
                return true;
            }
        }
        return false;
    }

    /**
     *  获取所有用户信息
     *  1：读取allUsrInfo文件中的所有用户信息
     *  2：将获取的用户信息按照接口要求拼接后返回给客户端
     * */
    if (pathname == '/getAllUserInfo') {
        var allUserInfo = getAllUserInfo();//获取所有用户信息
        var result = {};
        result.code = allUserInfo.length ? 0 : 1;
        result.msg = allUserInfo.length ? '获取所有用户信息成功' : "获取所有用户信息失败";
        result.data = allUserInfo;

        //将获取的信息返回给客户端
        res.writeHead(200, {'content-type': 'application/json;charset=utf8'});
        res.end(JSON.stringify(result));
        return;
    }

    /**
     *  获取所有指定用户信息
     *  1：获取请求url中的用户id
     *  2：获取所有用户信息
     *  3：在所有用户信息中找到和id号相同的用户信息
     *  4：返回找到后的用户信息
     * */
    if (pathname == '/getUserInfo') {
        var userId = query.id;//获取用户id
        var allUserInfo = getAllUserInfo();//获取所有用户信息
        var userInfo = getUserInfoFromId(allUserInfo, userId);//获取和id号相同的用户信息
        var result = {};
        result.code = userInfo ? 0 : 1;
        result.msg = userInfo ? '获取指定用户信息成功' : '获取指定用户信息失败';
        result.data = userInfo;

        //将获取的信息返回给客户端
        res.writeHead(200, {'content-type': 'application/json;charset=utf8'});
        res.end(JSON.stringify(result));
        return;
    }
    /**
     * 增加某个用户信息
     * 1：获取请求体中用户信息
     * 2：获取所有用户信息
     * 3：根据所有用户信息中最后一个用户确定新增客户的id号
     * 4：在所有用户信息末尾追加新增用户信息
     * 5：将新的所有用户信息写回到客户信息文件中
     * 6：按照接口样式将成功信息返回给客户端
     * */
    if (pathname == '/addUserInfo') {
        var addUser = '';
        req.on('data', function (chunck) {
            addUser += chunck;
        });
        req.on('end', function () {
            addUser = JSON.parse(addUser);//获取请求体中新增的客户信息
            var allUserInfo = getAllUserInfo();//获取所有用户信息
            (!allUserInfo) && (allUserInfo = []); //一个用户也没有，设置为[]空数组
            addUser.id = allUserInfo[allUserInfo.length - 1].id + 1;//新增用户id为最后一个用户id+1
            allUserInfo.push(addUser); //将新增用户追加到所有用户信息末尾
            fs.writeFileSync('./data/allUserInfo.json', JSON.stringify(allUserInfo), 'utf8'); //将所有用户信息写回文件中

            var result = {};
            result.code = 0;
            result.msg ='增加用户信息成功';

            //将获取的信息返回给客户端
            res.writeHead(200, {'content-type': 'application/json;charset=utf8'});
            res.end(JSON.stringify(result));
        })
    }

    /**
     * 修改某个用户的信息
     * 1：获取请求体中修改后的用户信息
     * 2：获取所有用户信息
     * 3：将所有用户信息中找到更新的用户，将信息进行修改
     * 4: 将修改后的用户信息写回到文件中
     * 5：将修改后的成功信息按照接口格式返回给客户端
     * */
    if (pathname == '/updateUserInfo'){
        var updateUser = '';
        req.on('data', function (chunck) {
            updateUser += chunck;
        });
        req.on('end', function () {
            console.log('updateUser:'+updateUser);
            updateUser = JSON.parse(updateUser);//获取请求体中更新的用户信息
            var allUserInfo = getAllUserInfo(); //获取所有用户信息
            (!allUserInfo) && (allUserInfo = []);
            var flag = updateUserFromUser(allUserInfo, updateUser); //更新用户信息

            fs.writeFileSync('./data/allUserInfo.json', JSON.stringify(allUserInfo), 'utf8');//将更新的后用户信息写回到文件中

            var result = {};
            result.code = flag ? 0:1;
            result.msg = flag?'更新用户信息成功':'更新用户信息失败';
            //将获取的信息返回给客户端
            res.writeHead(200, {'content-type': 'application/json;charset=utf8'});
            res.end(JSON.stringify(result));
        });
        return;
    }
    /**
     * 删除指定用户信息
     * 1: 获取请求url中的用户id
     * 2: 获取所有用户信息
     * 3: 在所有用户信息中找到删除的用户id匹配的用户并删除
     * 4: 将删除后的所有用户信息写回到文件中
     * 5: 按照接口要求将删除信息返回给客户端
     * */
    if (pathname == '/removeUserInfo'){
        var userId = parseInt(query.id);//获取删除用户的id
        var allUserInfo = getAllUserInfo();//获取所有用户信息
        var flag = removeUserFromId(allUserInfo, userId);//删除指定用户信息
        fs.writeFileSync('./data/allUserInfo.json', JSON.stringify(allUserInfo), 'utf8');//将更新的后用户信息写回到文件中

        var result = {};
        result.code = flag ? 0:1;
        result.msg = flag?'删除指定用户信息成功':'删除指定用户信息失败';
        //将获取的信息返回给客户端
        res.writeHead(200, {'content-type': 'application/json;charset=utf8'});
        res.end(JSON.stringify(result));
    }


});

server.listen(9999, function () {
    console.log('listening 9999 port success....');
});
```

### ajax封装代码
```
(function () {
    function createXHR() {
        var ary = [function () {
            return new XMLHttpRequest()
        }, function () {
            return new ActiveXObject('Microsoft.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function () {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }];
        var xhr = null;
        var flag = false;
        for (var i = 0; i < ary.length; i++) {
            var cur = ary[i];
            try {
                xhr = cur();//调用方法
                createXHR = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
                flag = true;//找到创建ajax的方法
                break; //结束循环
            } catch (err) {
                //报错, 继续执行后面的方法创建ajax对象
            }
        }
        if (!flag) { //没有找到适合当前浏览器创建ajax的方法
            throw errors('没有适合当前浏览器的创建ajax的方法');
        }
        return xhr;
    }

//ajax实现ajax请求的公共方法
    function ajax(options) {
        //把需要使用的参数值指定默认的初始值, 一旦没有传递的话可以使用默认值进行赋值
        var _default = {
            type: 'get', //请求方式
            url: null,  //请求url地址
            async: true,  //是否异步
            data: null,  //请求体数据
            dataType: 'json',//设置请求回来的数据格式'json'就是将请求回来的数据转换成json对象 'txt'就是请求回来的数据为字符串
            success: null   //请求成功时的回调
        };

        //使用实参替换默认值
        for (var attr in options) {  //遍历options
            if (options.hasOwnProperty(attr)) { //获取私有属性
                _default[attr] = options[attr];    //用options替换_default
            }
        }


        //解决get请求的缓存问题
        if (_default.type == 'get'){
            //如果url中已经包含'?'则在原有基础上增加&_=随机数, 否则url末尾增加?_=随机数, 解决get请求的缓存问题
            _default.url += (((_default.url.indexOf('?')>=0)?' &_=': '?_=')+Math.random());
        }


        //1: 实例化ajax对象
        var xhr = createXHR();

        xhr.open(_default.type, _default.url, _default.async);

        xhr.onreadystatechange = function () {
            if (/^2\d{2}$/.test(xhr.status)) {
                //状态码为4的时候
                if (xhr.readyState == 4) {
                    var val = xhr.responseText;
                    //如果传递的dataType类型是json, 说明获取的是json对象
                    if (_default.dataType == 'json') {
                        val = 'JSON' in window ? JSON.parse(val) : eval('(' + val + ')');
                    }
                    _default.success && _default.success.call(xhr, val);
                }
            }
        };
        //发送ajax请求, 参数是请求主体信息
        xhr.send(_default.data);
    }

    //将ajax变成全局属性
    window.ajax = ajax;
})();
```

### 用户数据信息
```
[
  {
    "name": "chenchao",
    "age": 18,
    "phone": "121232",
    "addr": "北京",
    "id": 4
  },
  {
    "name": "chenchao",
    "age": 18,
    "phone": "121232",
    "addr": "北京",
    "id": 7
  },
  {
    "name": "刘青云",
    "age": "55",
    "phone": "345678",
    "addr": "柬埔寨",
    "id": 8
  },
  {
    "name": "张国荣",
    "age": "56",
    "phone": "123456789",
    "addr": "世界",
    "id": 9
  },
  {
    "name": "大家好",
    "age": "22",
    "phone": "132453647568",
    "addr": "奋斗过后",
    "id": 11
  }
]
```

### 首页用户信息
> 首页index.html代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CRM客户管理系统</title>
    <link rel="stylesheet" href="css/index.css">
</head>
<body>
<div class="box" id="box">
    <a href="add.html" class="add">增加客户</a>
    <h2 class="header">
        <span>编号</span>
        <span>姓名</span>
        <span>年龄</span>
        <span>电话</span>
        <span>地址</span>
        <span>操作</span>
    </h2>
    <ul class="list" id="list">
        <!--<li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>
        <li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>
        <li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>
        <li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>
        <li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>
        <li>
            <span>1</span>
            <span>陈超</span>
            <span>18</span>
            <span>1122222</span>
            <span>北京</span>
        <span>
            <a href="#">修改</a>
            <a href="#">删除</a>
        </span>
        </li>-->

    </ul>
</div>
</body>
<script src="js/ajax.js"></script>
<script src="js/index.js"></script>
</html>
```
> 首页index.css代码
```
* {
    margin: 0;
    padding: 0;
}

html, body {
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    font-size: 14px;
    color: #000;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
}

ul, li {
    list-style: none;
}

a, a:hover, a:active, a:visited, a:target {
    text-decoration: none;
    color: #000;
}

.box {
    width: 800px;
    padding: 20px;
    margin: 50px auto;
    border: 2px solid lightgreen;
    overflow: hidden;
}

.add {
    display: block;
    height: 50px;
    font-size: 30px;
    font-weight: bold;
}

.add:hover {
    color: red;
    cursor: pointer;
}

.header {
    height: 40px;
    line-height: 40px;
    background: lightgreen;
    border-radius: 5px;
}

.header span, .list span {
    float: left;
    text-align: center;
    width: 16%;
}
.list li{
    height: 35px;
    line-height: 35px;
    font-size: 16px;
    cursor: pointer;
}
.list li:nth-child(even){
    background: lightcyan;
}
.list span{
    display: block;
    height: 35px;
    line-height: 35px;
}
.list li span a{
    display: inline-block;
    margin: 0 5px;
}
.list li span a:hover{
    color: red;
}
```
> 首页index.js代码
```
var userModule = (function () { //用户模块
    var userList = document.getElementById('list');
    function bindEvent(){
        userList.onclick = function (ev) {
            var target = ev.target || ev.srcElement;
            var targetTarName = target.tagName.toUpperCase();
            if (targetTarName == 'A' && target.id == 'removeUser'){
                ajax({
                    type: 'get',
                    url: '/removeUserInfo?id='+target.getAttribute('userId'),
                    async: true,
                    data: null,
                    dataType: 'json',
                    success: function (data) {
                        console.log(data);
                        if (data && data.code == 0){
                            window.location.href = '/index.html';
                        }
                    }
                });
            }
        };
    }

    //获取数据后绑定数据到页面
    function bindHTML(data) {
        if (data && data.code == 0){//数据存在并且请求成功
            var str = '';
            data.data.forEach(function (user, index) {
                str += '<li> <span>'+user.id+'</span> <span>'+user.name+'</span> <span>'+user.age+'</span> <span>'+user.phone+'</span> <span>'+user.addr+'</span> <span> <a href="/add.html?id='+user.id+'">修改</a> <a href="javascript:;" id="removeUser" userId="'+user.id+'">删除</a> </span> </li>';
            });
            userList.innerHTML = str;

            bindEvent();
        }
    }

    //用户模块入口方法
    function init() {
        ajax({
            type: 'get',
            url: '/getAllUserInfo',
            async: true,
            data: null,
            dataType: 'json',
            success: bindHTML
        });
    }

    return {
        init: init
    }
})();

userModule.init();

```

### 增加用户页代码
> 增加用户add.html代码
```
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CRM客户管理系统增加用户页</title>
    <link rel="stylesheet" href="css/add.css">
</head>
<body>
    <div class="box">
        <div>
            <span>姓名</span>
            <input type="text" id="userName">
        </div>
        <div>
            <span>年龄</span>
            <input type="text" id="userAge">
        </div>
        <div>
            <span>电话</span>
            <input type="text" id="userPhone">
        </div>
        <div>
            <span>地址</span>
            <input type="text" id="userAddr">
        </div>
        <div id="submit" class="submit">提交</div>
    </div>
</body>
<script src="js/ajax.js"></script>
<script src="js/add.js"></script>
</html>
```
> 增加用户add.css代码
```
* {
    margin: 0;
    padding: 0;
}

html, body {
    width: 100%;
    height: 100%;
    overflow-x: hidden;
    font-size: 14px;
    color: #000;
    font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
    -webkit-user-select: none;
}
input{
    outline: none;
}
.box{
    width: 500px;
    padding: 20px;
    margin: 50px auto;
    border: 2px solid lightgreen;
    border-radius: 10px;
}
span{
    display: inline-block;
    text-align: center;
    width: 80px;
    font-size: 16px;
}
div{
    margin: 5px 0;
}
input{
    width: 360px;
    padding: 0 10px;
    height: 40px;
    border: 1px solid lightgreen;
    border-radius: 3px;
    font-size: 16px;
}
.submit{
    width: 200px;
    height: 50px;
    line-height: 50px;
    text-align: center;
    margin: 20px auto;
    margin-bottom: 0;
    background: lightgreen;
    border-radius: 10px;
    font-size: 20px;
    cursor: pointer;
}
```
> 增加用户add.js代码
```
function queryParamsUrl(url){ //解析url末尾的参数信息
    var reg = /([^=#$?]+)=([^=#$?]+)/g;
    var obj = {};
    url.replace(reg, function () {
        var key = arguments[1];
        var value = arguments[2];
        obj[key] = value;
    });
    return obj;
}
var addModule = (function () {
    var submit = document.getElementById('submit');
    var userName = document.getElementById('userName');
    var userAge = document.getElementById('userAge');
    var userPhone = document.getElementById('userPhone');
    var userAddr = document.getElementById('userAddr');

    var query = queryParamsUrl(window.location.href);//解析url获取当前url的参数信息

    function sendAjaxAdd(data){
        ajax({
            type: 'post',
            url: '/addUserInfo',
            async: true,
            data: JSON.stringify(data),
            success: function (data) {
                if (data && data.code == 0){
                    window.location.href = '/index.html';
                }
            }
        });
    }
    function sendAjaxUpdate(data){
        ajax({
            type: 'post',
            url: '/updateUserInfo',
            async: true,
            data: JSON.stringify(data),
            success: function (data) {
                if (data && data.code == 0){
                    window.location.href = '/index.html';
                }
            }
        });
    }
    function sendAjaxGetInfo(){ //获取当前用户信息
        ajax({
            type: 'get',
            url: '/getUserInfo?id='+query.id,
            async: true,
            data: null,
            success: function (data) {
                if (data && data.code == 0){
                    userName.value = data.data.name;
                    userAge.value = data.data.age;
                    userPhone.value = data.data.phone;
                    userAddr.value = data.data.addr;
                }
            }
        });
    }
    function bindEvent(){
        submit.onclick = function () {
            var data = {  //获取提交的数据信息
                name: userName.value,
                age: userAge.value,
                phone: userPhone.value,
                addr: userAddr.value
            };
            if (!query.id){ //url末尾没有id信息，表示增加用户信息
                //发送ajax请求
                sendAjaxAdd(data);
            } else {
                data.id = query.id;
                //发送ajax请求
                sendAjaxUpdate(data);
            }
        }
    }
    function init(){
        if (query.id){ //如果是更新用户信息
            sendAjaxGetInfo(); //请求当前用户信息，展示当前用户的信息
        }

        //事件绑定
        bindEvent();
    }
    return {
        init: init
    }
})();
addModule.init();
```























































































### 客户端和服务器端交互模型中资源信息的查看
> 谷歌浏览器控制前台中的network这一项, 可以看到当前的浏览器向服务器发送的所有请求以及请求状态信息资源和服务器返回给客户端的所有信息
> 通过network中观察, 我们发现当我第一次把html源代码请求回来的时候,浏览器按照自己的引擎渲染, 在渲染过程中我们还会出现从新想服务器请求css/js/img...每一次的请求步骤和html请求步骤一样, 如果请求次数过多,页面打开的速度和玄谈的速度就会变慢, 所以我们以后在页面优化的方法中, 首先要做的就是减少资源请求数(减少http请求)
- css合并成一个或者如果css不是很多的话采用内嵌css
- js合并成一个 或者 采用内嵌式
- 图片合并, 合并成雪碧图sprite,或者 图片延迟加载
- ajax请求和资源文件的请求原理是一样的












