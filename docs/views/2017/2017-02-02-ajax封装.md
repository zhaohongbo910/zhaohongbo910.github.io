---
title: ajax 封装
date: 2017-02-02
permalink: /:year/:month/:day/:slug
tags:
  - JavaScript
categories:
  - JavaScript
---

### ajax 的封装

<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX"> Ajax </a>

## ajax介绍
- Ajax: async javascript and xml异步的javascript和xml
- 客户端中的js方法 用来向服务器发送请求(还可以传递给服务器相关数据url, 请求体), 然后把服务器返回的内容获取到(ajax一般是运行在客户端的浏览器中)
### ajax四步
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
      大家好
</body>
<script>
    //1: 创建一个ajax对象(ie6低版本不兼容)
    var xhr = new XMLHttpRequest();

    /**
     * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
     * 请求方式: get/post/put/delete/head
     * 请求地址: url, 可以传参
     * 是否异步: true异步, false同步
     * */
    xhr.open('get', './data.txt', false);
    /**
     * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
     *
     * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
     *
     * UNSENT:0 未发送
     * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
     * HEADERS_RECEIVED:2 响应头信息已经接受
     * LOADING:3 响应体的内容正在服务器端进行准备处理
     * DONE:4 响应体的内容已经成功返回给客户端
     *
     * xhr.status: http响应状态码
     * 1开头: 消息
     * 2开头: 成功
     * 3开头: 重定向
     * 4开头: 客户端错误
     * 5开头: 服务器错误
     * */
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)){
            console.log(xhr.responseText);
        }
    };
    /**
     * 发送ajax请求
     * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
     * */
    xhr.send(null);
</script>
</html>
```

### 创建ajax对象封装
```js
//1: 创建一个ajax对象(ie6低版本不兼容)
var xhr = null;

/*if (window.XMLHttpRequest) {
 xhr = new XMLHttpRequest();
 /!**
 * 兼容ie低版本, 但是这样写不合理, 不合理原因是什么???如何解决??
 * 由于new ActiveXObject('Microsoft.XMLHTTP')程序直接报错, 根本无法判断
 * 解决方法: 使用try-catch
 * *!/
 } else if (new ActiveXObject('Microsoft.XMLHTTP')) {
 xhr = new ActiveXObject('Microsoft.XMLHTTP');
 } else if (new ActiveXObject('Msxml2.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml2.XMLHTTP');
 } else if (new ActiveXObject('Msxml3.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml3.XMLHTTP');
 }*/

//使用try-catch创建ajax对象
function createXHR() {
    try {
        xhr = new XMLHttpRequest();
    } catch (err) {
        try {
            xhr = new ActiveXObject('Microsoft.XMLHTTP');
        } catch (err) {
            try {
                xhr = new ActiveXObject('Msxml2.XMLHTTP');
            } catch (err) {
                xhr = new ActiveXObject('Msxml3.XMLHTTP');
            }
        }
    }
}

//创建ajax对象
var xhr = createXHR();

/**
 * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
 * 请求方式: get/post/put/delete/head
 * 请求地址: url, 可以传参
 * 是否异步: true异步, false同步
 * */
xhr.open('get', './data.txt', false);
/**
 * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
 *
 * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
 *
 * UNSENT:0 未发送
 * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
 * HEADERS_RECEIVED:2 响应头信息已经接受
 * LOADING:3 响应体的内容正在服务器端进行准备处理
 * DONE:4 响应体的内容已经成功返回给客户端
 *
 * xhr.status: http响应状态码
 * 1开头: 消息
 * 2开头: 成功
 * 3开头: 重定向
 * 4开头: 客户端错误
 * 5开头: 服务器错误
 * */
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)) {
        console.log(xhr.responseText);
    }
};
/**
 * 发送ajax请求
 * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
 * */
xhr.send(null);
```

> 上面代码try-catch重复嵌套, 代码不美观, 程序中多次调用createXHR方法每次调用都要进行从上到下的判断, 但是在程序中第一次调用的时候判断一次后, 以后浏览器类型就能够确定, 无需再次重复判断
- 惰性思想封装ajax对象创建

```js
//1: 创建一个ajax对象(ie6低版本不兼容)
var xhr = null;

/*if (window.XMLHttpRequest) {
 xhr = new XMLHttpRequest();
 /!**
 * 兼容ie低版本, 但是这样写不合理, 不合理原因是什么???如何解决??
 * 由于new ActiveXObject('Microsoft.XMLHTTP')程序直接报错, 根本无法判断
 * 解决方法: 使用try-catch
 * *!/
 } else if (new ActiveXObject('Microsoft.XMLHTTP')) {
 xhr = new ActiveXObject('Microsoft.XMLHTTP');
 } else if (new ActiveXObject('Msxml2.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml2.XMLHTTP');
 } else if (new ActiveXObject('Msxml3.XMLHTTP')) {
 xhr = new ActiveXObject('Msxml3.XMLHTTP');
 }*/

/*
//使用try-catch创建ajax对象
function createXHR() {
    try {
        xhr = new XMLHttpRequest();
    } catch (err) {
        try {
            xhr = new ActiveXObject('Microsoft.XMLHTTP');
        } catch (err) {
            try {
                xhr = new ActiveXObject('Msxml2.XMLHTTP');
            } catch (err) {
                xhr = new ActiveXObject('Msxml3.XMLHTTP');
            }
        }
    }
}
*/

function createXHR(){
    var ary = [function () {
        return new XMLHttpRequest()
    }, function () {
        return new ActiveXObject('Microsoft.XMLHTTP');
    }, function () {
        return new ActiveXObject('Msxml2.XMLHTTP');
    },function () {
        return new ActiveXObject('Msxml3.XMLHTTP');
    }];
    var xhr = null;
    var flag = false;
    for (var i=0; i<ary.length; i++){
        var cur = ary[i];
        try {
            xhr = cur();//调用方法
            createXHR  = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
            flag = true;//找到创建ajax的方法
            break; //结束循环
        } catch (err){
            //报错, 继续执行后面的方法创建ajax对象
        }
    }
    if (!flag){ //没有找到适合当前浏览器创建ajax的方法
        throw errors('没有适合当前浏览器的创建ajax的方法');
    }
    return xhr;
}


//创建ajax对象
var xhr = createXHR();

/**
 * 发送请求前的配置信息(请求方式, 请求url, 是否异步)
 * 请求方式: get/post/put/delete/head
 * 请求地址: url, 可以传参
 * 是否异步: true异步, false同步
 *  
 * ajax中的同步编程: 当ajax任务开始的时候, 一直到readyState为4的时候任务才结束, 此时才可以处理处理其他的操作
 * ajax中的异步编程: 当ajax任务开始的时候, 不需要等到readyState状态变成4, 可以在执行其他的操作, 当readyState状态为4的时候会回来继续执行ajax后续的操作
 * */
xhr.open('get', './data.txt', false);
/**
 * onreadystatechange监听ajax请求状态的变化, 只要状态变化就会触发该方法
 *
 * xhr.readyState: ajax状态码, 可以代表当前ajax请求进度
 *
 * UNSENT:0 未发送
 * OPENED:1 url地址已经打开(发送前的参数配置已经完成)
 * HEADERS_RECEIVED:2 响应头信息已经接受
 * LOADING:3 响应体的内容正在服务器端进行准备处理
 * DONE:4 响应体的内容已经成功返回给客户端
 *
 * xhr.status: http响应状态码
 * 1开头: 消息
 * 2开头: 成功
 * 3开头: 重定向
 * 4开头: 客户端错误
 * 5开头: 服务器错误
 * */
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 && /^2\d{2}$/.test(xhr.status)) {
        console.log(xhr.responseText);
    }
};
/**
 * 发送ajax请求
 * 参数是客户端发送服务器的信息, 如果是post请求会把请求体数据存放到该参数中, get请求一般直接写null, 使用url传参
 * */
xhr.send(null);

```


## 完整封装

```js
(function() {
  function createXHR() {
    var ary = [
      function() {
        return new XMLHttpRequest();
      },
      function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      },
      function() {
        return new ActiveXObject("Msxml2.XMLHTTP");
      },
      function() {
        return new ActiveXObject("Msxml3.XMLHTTP");
      },
    ];
    var xhr = null;
    var flag = false;
    for (var i = 0; i < ary.length; i++) {
      var cur = ary[i];
      try {
        xhr = cur(); //调用方法
        createXHR = cur; //调用成功, 替换createXHR为适合当前浏览器的创建ajax方法
        flag = true; //找到创建ajax的方法
        break; //结束循环
      } catch (err) {
        //报错, 继续执行后面的方法创建ajax对象
      }
    }
    if (!flag) {
      //没有找到适合当前浏览器创建ajax的方法
      throw errors("没有适合当前浏览器的创建ajax的方法");
    }
    return xhr;
  }

  //ajax实现ajax请求的公共方法
  function ajax(options) {
    //把需要使用的参数值指定默认的初始值, 一旦没有传递的话可以使用默认值进行赋值
    var _default = {
      type: "get", //请求方式
      url: null, //请求url地址
      async: true, //是否异步
      data: null, //请求体数据
      dataType: "json", //设置请求回来的数据格式'json'就是将请求回来的数据转换成json对象 'txt'就是请求回来的数据为字符串
      success: null, //请求成功时的回调
    };

    //使用实参替换默认值
    for (var attr in options) {
      //遍历options
      if (options.hasOwnProperty(attr)) {
        //获取私有属性
        _default[attr] = options[attr]; //用options替换_default
      }
    }

    //解决get请求的缓存问题
    if (_default.type == "get") {
      //如果url中已经包含'?'则在原有基础上增加&_=随机数, 否则url末尾增加?_=随机数, 解决get请求的缓存问题
      _default.url +=
        (_default.url.indexOf("?") >= 0 ? " &_=" : "?_=") + Math.random();
    }

    //1: 实例化ajax对象
    var xhr = createXHR();

    xhr.open(_default.type, _default.url, _default.async);

    xhr.onreadystatechange = function() {
      if (/^2\d{2}$/.test(xhr.status)) {
        //状态码为4的时候
        if (xhr.readyState == 4) {
          var val = xhr.responseText;
          //如果传递的dataType类型是json, 说明获取的是json对象
          if (_default.dataType == "json") {
            val = "JSON" in window ? JSON.parse(val) : eval("(" + val + ")");
          }
          _default.success && _default.success.call(xhr, val);
        }
      }
    };
    //发送ajax请求, 参数是请求主体信息
    xhr.send(_default.data);
  }

  //将ajax变成全局属性
  window.ajax = ajax;
})();
```
