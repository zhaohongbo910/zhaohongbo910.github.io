---
title: 浏览器常见考点汇总  
date: 2017-01-06
permalink: /:year/:month/:day/:slug
tags:
 - 面试 
 - Css3
 - HTML5
categories: 
 - 前端
---


## 2. 渲染线程和 JS 引擎线程

浏览器中常见的线程有：**GUI渲染线程**、**JS 引擎线程**、**事件触发线程**，**定时触发器线程**，**异步http请求线程**等等。

**JS引擎线程**
:::tip
也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）JS引擎线程负责解析Javascript脚本，运行代码。
一个renderer进程中无论什么时候都只有一个JS线程在运行JS程序,JS引擎一直等待着任务队列中任务的到来，然后加以处理，
同样注意，**GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。**
:::

**事件触发线程**
:::tip
归属于浏览器而不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
当JS引擎执行代码块如鼠标点击、AJAX异步请求等会将对应任务添加到事件线程中,当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理 **注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）**
:::
**定时触发器线程**
:::tip
传说中的setInterval与setTimeout所在线程,浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
**注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。**
:::
**异步http请求线程**
:::tip
在XMLHttpRequest在连接后是通过浏览器新开一个线程请求,将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。
:::

## 3. 重绘和回流（重排）

**3.1重绘（repaint）：** 屏幕的一部分要重绘。渲染树节点发生改变，但不影响该节点在页面当中的空间位置及大小。譬如某个div标签节点的背景颜色、字体颜色等等发生改变，但是该div标签节点的宽、高、内外边距并不发生变化，此时触发浏览器重绘（repaint）。

**3.2重排（reflow）：** 也有称回流，当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式："display:none;"。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。

重绘（repaint）和回流（reflow）会在样式节点变动时候出现，回流所需要的成本更高，**回流一定会引重绘。**

重绘是只一些元素更新属性，这些属性只影响外观，不影响布局。比如背景颜色、字体颜色等等。

回流是元素的尺寸、布局、可见等属性发生改变。会导致渲染树重新构造。比如窗口字体大小变化、样式表改动、元素内容（尤其是输入控件）、css 伪类激活、offsetWidth 等属性计算。

### **何时回引起重排？**

当页面布局和几何属性改变时就需要重排。下述情况会发生浏览器重排：
- 1、添加或者删除可见的DOM元素；
- 2、元素位置改变——display、float、position、overflow等等；
- 3、元素尺寸改变——边距、填充、边框、宽度和高度
- 4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
- 5、页面渲染初始化；
- 6、浏览器窗口尺寸改变——resize事件发生时；

### **如何减少重绘回流？**

- 避免逐项更改样式。**一次性更改`style`属性，或者直接定义`class`属性**
- 避免直接插入`DOM`。**在`documentFragment`上操作，然后再插入`document`中**
- 使用display:none技术，只引发两次回流和重绘；
- 使用cloneNode(true or false) 和 replaceChild 技术，引发一次回流和重绘；
- 避免循环读取`offsetWidth`等属性。**循环外存取**
- 避免复杂动画。**利用绝对定位将其脱离文档流**
- 避免`CSS`选择符层级太多。**尽量平级类名，参考 scss 中的`&`的用法**
- 不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存

- 为频繁重绘或者回流的节点设置图层：
  - `iframe`、`video` 等节点自动变为图层
  - 通过 3d 动画出发：`transform: translate3d(0, 0, 0)`
- 提前通知浏览器：[`will-change` 属性](https://developer.mozilla.org/zh-CN/docs/Web/CSS/will-change)

## 4. 页面生命周期

`onload`和`DOMContentLoaded`触发的先后顺序是什么？

页面声明周期的变化，会触发`document`上的`readystatechange`事件，用户可以通过`document.readyState`拿到当前的状态。

```javascript
// 初始时候的readyState
console.log(document.readyState);
// 每次改变都打印readyState
document.addEventListener("readystatechange", () =>
	console.log(document.readyState);
);
```

上面的代码在 Chrome 中的输出是：

1. loading：加载 document
2. interactive：document 加载成功，DOM 树构建完成
3. complete：图像，样式表和框架之类的子资源完成加载

**所以，`DOMContentLoaded`是在`onload`前进行的**。

- `DOMContentLoaded`事件在 DOM 树构建完毕后被触发，我们可以在这个阶段使用 js 去访问元素。
  - `async`和`defer`的脚本可能还没有执行。
  - 图片及其他资源文件可能还在下载中。
- `load`事件在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。
- `beforeunload`在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。
- ~~`unload`在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。~~

```javascript
document.addEventListener("DOMContentLoaded", () => {
  console.log("DOMContentLoaded");
});
window.addEventListener("load", () => {
  console.log("load");
});
window.addEventListener("beforeunload", () => {
  console.log("will unload");
});

window.addEventListener("unload", () => {
 	console.log("unload");
});

```

## 7. 请求的几种对象

### 7.1 XMLHttpRequest

```js
function objTOstr(data) {
    data = data || {}; // 如果没有传参, 为了添加随机因子,必须自己创建一个对象
    data.t = new Date().getTime();
    var res = [];
    for (var key in data){
        //在URL中是不可以出现中文的，如果出现了中文需要转码，可以调用encodeURIComponent方法，URL中只可以出现字母、数字、下划线、ASCII码
        res.push(encodeURIComponent(key)+"="+encodeURIComponent(data[key]));
    }
    return res.join("&");
}
function ajax(option){
    var str = objTOstr(option.data);//key=value&key=value;
    var xmlhttp,timer;
    if (window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari
        xmlhttp=new XMLHttpRequest();
    }else{// code for IE6, IE5
        xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
    }
    if (option.type.toLowerCase()==="get") {//toLowerCase将大写转化为小写
        xmlhttp.open(option.type,option.url+"?"+str,true)
        xmlhttp.send();
    }else{
        xmlhttp.open(option.type,option.url,true);
        //注意点:以下代码必须放在open和send之间
        xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");
        xmlhttp.send(str);
    }
    xmlhttp.onreadystatechange = function (ev2) {
        if (xmlhttp.readyState === 4){
            clearInterval(timer);
            //判断是否请求成功(Http状态码大于等于200，且小于300，和状态码等于304为请求成功)
            if (xmlhttp.status>=200&&xmlhttp.status<300||xmlhttp.status===304) {
                option.success(xmlhttp);
            }else{
                option.error(xmlhttp);
            }
        }
    };
    if (option.timeout){
        timer = setInterval(function () {
            console.log("中断请求");
            xmlhttp.abort();
            clearInterval(timer);
        },option.timeout);
    }
}

```

### 7.2 Fetch API

> 题目：介绍和使用`fetch()`

淘汰了写法不舒服的`XMLHttpRequest`，本身支持`Promise`回调，是 ES6 下的最佳 AJAX 实践。但是浏览器兼容不是太好，但几年后，估计就只剩它了！

```javascript
const api = "http://localhost:8080/"
const formData = new FormData();
formData.append("key", "周杰伦");
formData.append("page", 1);
formData.append("limit", 10);
formData.append("vendor", "qq");
fetch(api, {
  method: "POST",
  body: formData
})
  .then(res => res.json())
  .then(json => console.log(json));
```

**注意**：`koabodyparser`不支持`FormData`解析（换用`koa-better-body`）。那么请用如下代码。

```javascript
const api = "http://localhost:5050/search/song";
fetch(api, {
  method: "POST",
  body: JSON.stringify({
    key: "周杰伦",
    page: 1,
    limit: 10,
    vendor: "qq"
  }),
  headers: new Headers({
    "Content-Type": "application/json"
  })
})
  .then(res => res.json())
  .then(json => console.log(json));
```

### 7.3 实现跨域

> 题目：如何实现跨域？

- JSONP：通过`<script>`标签实现，但是只能实现`GET`请求
- 代理转发：Webpack 的 dev 模式，配合`proxy`选项，**启动一个前端服务器**，实现代理转发
- **CORS**：后端允许跨域资源共享，这是我最推荐的一种方法
- **document.domain** 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。
- **postMessage** 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
```js
// 发送消息端
window.parent.postMessage('message', 'http://test.com')
// 接收消息端
var mc = new MessageChannel()
mc.addEventListener('message', event => {
  var origin = event.origin || event.originalEvent.origin
  if (origin === 'http://test.com') {
    console.log('验证通过')
  }
})
```
**注意**：`src`的`params`中`callback`属性，指定的是回调函数。实例的回调函数是：`handleResponse()`

```javascript
// 定义回调函数
const handleResponse = data => {
  console.log(data);
};

// 构造 <script> 标签
let script = document.createElement("script");
script.src =
  "https://api.douban.com/v2/book/search?q=javascript&count=1&callback=handleResponse";

// 向document中添加 <script> 标签，并且发送GET请求
document.body.appendChild(script);
```
