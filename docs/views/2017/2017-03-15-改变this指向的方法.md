---
title: 改变this指向的方法   
date: 2017-03-15
permalink: /:year/:month/:day/:slug
tags:
- JavaScript
- 面试
categories: 
 - 前端
sidebar: false
autoGroup: javaScript
---
::: tip 
浅谈 **this 默认绑定、隐式绑定、显式绑定、new绑定、箭头函数绑定**
:::

**this 默认绑定** 
::: tip
 **1.函数调用前无任何调用前缀的情况 自动绑定 this**  <br/>
 **2.与其调用的环境有关系 浏览器环境当中则为 window对象 ,Node 环境当中 则为 global 对象 (非严格模式下)** <br/>
 **3.在严格模式下面 浏览器你和Node this 都为 undefined** <br/>
 **4.严格模式下调用不在严格模式中的函数，并不会影响this指向** <br/>
:::
```js
    function fn1() {
        let fn2 = function () {
            console.log(this);  
        };
        console.log(this); 
        fn2();
    };

    function fn3() {
        "use strict"
        fn1()
        console.log(this);
    };
    fn1();
    fn3();
```
**this隐式绑定**
::: tip
**1.如果函数调用时，前面存在调用它的对象，那么this就会隐式绑定到这个对象上** <br/>
**2.如果函数调用前存在多个对象，this指向距离调用自己最近的对象**
:::
```js
    // 第一情况
    function fn() {
        console.log(this.name);
    };
    let obj = {
        name: '小布丁',
        fun: fn
    };
    obj.fun() // 小布丁

    let obja = {
        name:'青春就是懵懂中度过的',
        o:obj
    }

    obja.o.fun() // 小布丁
```
::: warning
:tada: :100: :scream:
**作用域链与原型链的区别**
:::
::: tip 
***1.当访问一个变量时，解释器会先在当前作用域查找标识符，如果没有找到就去父作用域找，作用域链顶端是全局对象window，如果window都没有这个变量则报错。注意是报错*** <br/>
***2.当在对象上访问某属性时，首选会查找当前对象，如果没有就顺着原型链往上找，原型链顶端是null，如果全程都没找到则返一个undefined，而不是报错。这里不报错***
:::

::: danger
**this隐式绑定丢失的问题** <br/>
1.在特定情况下会存在隐式绑定丢失的问题，最常见的就是**作为参数传递以及变量赋值**  
:::
```js
    var name = '黄河之水天上来';
    let obj = {
        name: '奔流到海不复回',
        fn: function () {
            console.log(this.name);
        }
    };

    function fn1(param) {
        param();
    };
    // 这里Obj.fn 作为了参数传递了给了 fn 函数 ---> fn 函数的调用主题发生了变化 是 window 
    fn1(obj.fn);//黄河之水天上来

```
**this显式绑定**
::: tip
this显式绑定 **通过call、apply以及bind方法改变this的行为**

**1.指向参数提供的是null或者undefined，那么 this 将指向全局对象。**
:::

```js
    let obj1 = {
        name: '白日依山尽'
    };
    let obj2 = {
        name: '黄河入海流'
    };
    let obj3 = {
        name: '欲穷千里目'
    }

    var name ='更上一层楼';

    function fn() {
        console.log(this.name);
    };
    fn(); // 更上一层楼  --> 这是window 调用 最后的 name 属于全局变量 挂在window对象下面 
    fn.call(obj1); //白日依山尽
    fn.apply(obj2); //黄河入海流
    fn.bind(obj3)(); //欲穷千里目

    // 指向参数提供的是null或者undefined，那么 this 将指向全局对象
    fn.call(undefined); //更上一层楼
    fn.apply(null); //更上一层楼
    fn.bind(undefined)(); //更上一层楼

    // bind 硬绑定
    let boundFn = fn.bind(obj1);//白日依山尽
    boundFn.call(obj2);//白日依山尽
    boundFn.apply(obj2);//白日依山尽
    boundFn.bind(obj2)();//白日依山尽

```
::: warning
:stuck_out_tongue: :stuck_out_tongue: :stuck_out_tongue: <br/>
**call、apply与bind有什么区别？**<br/>

**1.call、apply与bind都用于改变this绑定，但call、apply在改变this指向的同时还会执行函数，而bind在改变this后是返回一个全新的boundFcuntion绑定函数，这也是为什么上方例子中bind后还加了一对括号 ()的原因。**<br/>

**2.bind属于硬绑定，返回的 boundFunction 的 this 指向无法再次通过bind、apply或 call 修改；call与apply的绑定只适用当前调用，调用完就没了，下次要用还得再次绑。**<br/>

**3.call与apply功能完全相同，唯一不同的是call方法传递函数调用形参是以散列形式，而apply方法的形参是一个数组。在传参的情况下，call的性能要高于apply，因为apply在执行时还要多一步解析数组。**<br/>

:::

**new绑定**
::: tip
:handshake: :handshake: (可以点)
**[NEW关键字详解](../2018/2018-01-10-NEW关键字)** 
::: 

**箭头函数的this**
::: tip
***箭头函数中没有this，箭头函数的this指向取决于外层作用域中的this，外层作用域或函数的this指向谁，箭头函数中的this便指向谁。**<br/>
**一旦箭头函数的this绑定成功，也无法被再次修改** (当然，箭头函数的this也不是真的无法修改，箭头函数的this就像作用域继承一样从上层作用域找，因此我们可以修改外层函数this指向达到间接修改箭头函数this的目的。)
:::
```js
    function fn() {
        return () => {
            console.log(this.name);
        };
    }
    let obj1 = {
        name: '丽丽'
    };
    let obj2 = {
        name: '娜娜'
    };
    let bar = fn.call(obj1); 
    bar()   // this指向obj1 // 丽丽
    bar.call(obj2); // 丽丽  

    // 箭头函数改变 this 在上层间接改变
    fn.call(obj1)(); //fn this指向obj1,箭头函数this也指向obj1
    fn.call(obj2)(); //fn this 指向obj2,箭头函数this也指向obj2

```

