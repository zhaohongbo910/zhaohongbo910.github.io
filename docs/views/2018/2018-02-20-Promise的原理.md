---
title: Promise的原理
date: 2018-02-20
tags:
 - JavaScript 
 - Promise       
categories: 
 - 前端
sidebar: false
---

```ts
const isFunction = (fn:Function) => typeof fn === 'function';
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'
class MyPromise {
    _status:string;
    _value:any;
    _fulfilledQueues:Array<any>;
    _rejectedQueues:Array<any>;
    constructor(handle:Function) {
        if(!isFunction(handle)){
            throw new Error('MyPromise must accept a function as parameter')
        };
        // 添加状态
        this._status = PENDING;
        // 添加状态
        this._value = undefined;
        // 添加成功回调的任务队列
        this._fulfilledQueues = [];
        // 添加失败回调任务队列
        this._fulfilledQueues = [];

        try {
            //执行传入的 handle 函数 ，并且改变this 指向
            handle(this._resolve.bind(this),this._reject.bind(this))
        } catch (error) {
            this._reject(error)
        }
    }

    //将状态 变成 成功 pending -- fulfilled
    _resolve(val:any){
        if (this._status !== PENDING ) return
        this._status = FULFILLED;
        this._value = val;
    };

    //将状态 变成 失败 pending -- reject
    _reject(err:any){
        if(this._status !== PENDING) return;
        this._status = REJECTED
        this._value = err
    };

    // then 方法
    then(onFulfilled?:any,onRejected?:any){
        const { _status,_value } = this;
        // 返回
        return new MyPromise((onFulfilledNext:Function,onRejectedNext:Function)=>{
            
            let fulfilled = (value:any) => {
                try {
                    if(!isFunction(onFulfilled)){
                       onFulfilledNext(value);     
                    }else{
                        let res = onFulfilled(value);
                        if(res instanceof MyPromise){
                            //如果当前对象返回了 MyPromise 对象
                            res.then(onFulfilledNext,onRejectedNext)
                        }else{
                            onFulfilledNext(res);
                        }
                    }
                } catch (error) {
                    onFulfilledNext(error);
                }
            }

            let rejected = (error:any) =>{
                try {
                    if(!isFunction(onRejected)){
                        onFulfilledNext(error)
                    }else{
                        let res = onRejected(error);
                        if(res instanceof MyPromise){
                           res.then(onFulfilledNext,onFulfilledNext) 
                        }else{
                            onFulfilledNext(res)
                        }
                    }
                } catch (error) {
                    onRejectedNext(error);
                }
            }

            switch(_status){
                case PENDING:
                    this._fulfilledQueues.push(onFulfilled);
                    this._rejectedQueues.push(onRejected);
                    break;
                case FULFILLED:
                    fulfilled(_value);
                    break;
                case REJECTED:
                    rejected(_value);
                    break; 
    
            }

        })
    }
}

```
### 未完待续