---
title: React面试问题  
date: 2018-02-05
tags:
 - 面试 
 - React
categories: 
 - 前端
---

## 1.react有哪几个生命周期？（8个）
+ 初始化阶段
    + getDefaultProps:获取实例的默认属性 (只支持 React.createClass 创建的组件)
    + getInitialState:获取每个实例的初始化状态 (只支持 React.createClass 创建的组件)
    + **constructor()**

    + **componentWillMount：组件即将被装载、渲染到页面上** (快要废弃了)
    + **render:组件在这里生成虚拟的 DOM 节点**
    + **componentDidMount:组件真正在被装载之后** 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。

+ 运行中状态： 当组件的props 或者state 更新之后
    + **componentWillReceiveProps(nextProps):组件将要接收到属性的时候调用** (快要废弃了)
    + **shouldComponentUpdate: 组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）** 
    + **componentWillUpdate:组件即将更新不能修改属性和状态** (快要废弃了)
    + **render:组件重新描绘** 
    + **getSnapshotBeforeUpdate(prevProps, prevState)** getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 componentDidUpdate()。
    + **componentDidUpdate(prevProps, prevState, snapshot): 组件已经更新**  会在更新后会被立即调用。首次渲染不会执行此方法。
+ 销毁阶段：
    + **componentWillUnmount:组件即将销毁**   会在组件卸载及销毁之前直接调用。在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅等。 

## 2.在哪个生命周期做优化？
::: tip
shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。
:::
## 3.react怎么从虚拟dom中拿出真实dom?(ref）
:::tip
Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：
::: 

```js
    class CustomForm extends Component {
        handleSubmit = () => {
            console.log("Input Value: ", this.input.value)
        }
        render () {
            return (
            <form onSubmit={this.handleSubmit}>
                <input
                type='text'
                ref={(input) => this.input = input} />
                <button type='submit'>Submit</button>
            </form>
            )
        }
    }
```

## 4.react的diff算法是怎么完成的？(基础原理）
::: tip
React采用虚拟DOM技术实现对真实DOM的映射，即React Diff算法的差异查找实质是对两个JavaScript对象的差异查找；
基于三个策略：
+ Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。（tree diff）
+ 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结（component diff）
+ 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。（element diff）
:::
**tree diff**
::: tip
基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。
既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React只会对相同层级的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在时，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。   
::: 
+ 把树形结构按照层级分解，只比较同级元素。
+ 给列表结构的每个单元添加唯一的 key 属性，方便比较。
+ React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）
+ 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.
+ 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。

## 5.React中的props和state的用法
::: tip
1、props和state之间是紧密相关的。父组件的state传入转变子组件的就会变成props
2、state 是一个组件自身的状态集合，一般用于组件内部的状态维护，更新组建内部的数据，状态，更新子组件的props等。利用`this.setState({})` 进行state的更新操作
3、props 一般用于父组件向子组件通信，在组件之间通信使用。
:::

## 6.Redux的流程中间件（react-thunk,redux-promise,redux-saga,redux-logger   dvtools的理解，用法）
::: tip
:blush: 中间件就是一个函数，对store.dispatch方法进行了改造，在发出 Action 和执行 Reducer 这两步之间，添加了其他功能。
:::
**redux-thunks**:处理异步的中间件 redux-thunk 中间件的功能也很简单。首先检查参数 action 的类型，如果是函数的话，就执行这个 action 韩湖水，并把 dispatch, getState, extraArgument 作为参数传递进去，否则就调用 next 让下一个中间件继续处理 action 。react-thunk 比较适合于简单的API请求的场景，其store下的actions只是普通的actionCreator，真正异步操作放在API里  **api 异步操作 => action => reducer**

**redux-promise:** 处理异步的中间件

**redux-saga**:用于代替 redux-thunk 的。它通过创建 Sagas 将所有异步操作逻辑存放在一个地方进行集中处理，以此将react中的同步操作与异步操作区分开来，以便于后期的管理与维护。对于Saga，

**比较**
**1、redux-thunk 的缺点在于api层与store耦合，优点是比较灵活，易于控制** <br/>
**2、redux-promise的优点是api层与store解耦，缺点是对请求失败，请求中的情形没有很好的处理**<br/>
**3、redux-saga 的优点是api层与store解耦，对请求中，请求失败都有完善的处理，缺点是代码量较大。**<br/>

**redux-dvtools**:可以用于调试redux中的状态更改，我们可以清晰的看到当前store仓库中的state是怎么样的，在可视化工具的左边，我们还可以看到触发的action的变化。

## 7.比较redux和vuex,Flux的区别

+ 1、Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。
+ 2、redux 不仅可以用在vue,react,其他一切需要状态管理的应用中
+ 3、数据的流向不同
    + vuex的流向：
        + view——>commit——>mutations——>state变化——>view变化（同步操作）
        + view——>dispatch——>actions——>mutations——>state变化——>view变化（异步操作）

    + redux的流向：
        + view——>actions——>reducer——>state变化——>view变化（同步异步一样）
+ 4、Vuex相对于Redux的不同点有:
    + （1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch,只需在对应的mutation函数里改变state值即可
    + （2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可
    + （3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数->store改变(vue检测到数据变化自动渲染)

+ 5、Redux相对于Flux的改进：
    + （1）把store和Dispatcher合并,结构更加简单清晰新增state角色，代表每个时间点store对应的值，对状态的管理更加明确
    + （2）Redux数据流的顺序是:View调用store.dispatch发起Action->store接受Action(action传入reducer函数reducer函数返回一个新的state)->通知store.subscribe订阅的重新渲染函数


## 8.react-router3是否用过，router4是否用过，3到4有什么改变
+ 1、react-router3的包是react-router， router4的包是react-router-dom 最直观的是包发生了变化
+ 2、API 发生了变化
    + V3 中的 Router 不在了，在 V3 中，我们是将整个庞大的 Router 直接丢给 DOM，而在 V4 中，除了 BrowserRouter，我们丢给 DOM 的是我们的应用程序本身
    + V4 中，我们不再使用 `{props.children}` 来嵌套组件了，替代的 `<Route></Route>`，当 route 匹配时，子组件会被渲染到 `<Route></Route>` 书写的地方
    + V4 中也没有 `<IndexRoute>`，但 `<Route exact>` 可以实现相同的功能，或者 `<Switch>` 和 `<Redirect>` 重定向到默认的有效路径，甚至一个找不到的页面
+ 3、路由匹配的规则发生了变化
    + V3 中的 routing 规则是 exclusive，意思就是最终只获取一个 `<Route></Route>`，
    + V4 中的 routes 默认是 inclusive 的，这就意味着多个 `<Route>`可以同时匹配和呈现,通过 exact 这么一个 props，可以更改匹配的规则变成V3的匹配规则

## 9.react是什么层面上的框架，数据流是单向流还是双向绑定
::: tip
 react是应用层面的框架，react 本质上单向流，数据只能从父组件想组件传递
:::

## 10.React Render Callback Pattern(渲染回调模式)




## 高阶组件(HOC) : 而言，高阶组件是参数为组件，返回值为新组件的函数。
```js
 const EnhancedComponent = higherOrderComponent(WrappedComponent);
```
当您想要重用组件逻辑时，高阶组件(简称HOC)非常有用。 它们是 JavaScript 函数，它将组件作为参数并返回一个新组件。

+ 高阶组件存在的问题
    + 静态方法丢失
    + refs 属性不能透传  React 为我们提供了一个名为 React.forwardRef 的 API 来解决这一问题（在 React 16.3 版本中被添加）：
    + 反向继承不能保证完整的子组件树被解析


难易程度 等级（!,!!,!!!）
 
1.js的垃圾回收机制是什么原理（js）!!
 
2.经常遇到的解决js兼容性问题列举至少三个（js）!
 
3.不设置寛高的div，用至少两种方法，让它相对于页面水平垂直居中。（css）! -->
<!--  
4.react-redux的实现原理（react框架）!!
 
5.git经常用到的命令，至少五个，并且要说出每个命令是干什么的。（git add .）（git commit -m “”）（git push origin **）（git clone）（git branch）（git checkout）!
 
6.react-router的实现原理 !
 
7.react的生命周期（必须知道并且知道每个的作用）!
 
8.数组的方法（至少说出6个）（js）!
 
9.闭包的原理（js）!
 
10.伪数组转成真数组的方法（至少两种方法） （js）!!
  -->
<!-- 11.rgba和opacity的区别（css）!
 
12.link和inport的区别 （js）!
 
13.哪些操作会造成内存泄露（至少三个）（js）!!!
 
14.react虚拟DOM实现原理 !!
 
15.call，apply，bind的区别（js）!!!
 
16.ES6有哪些新特性  !
 
17.H5新特性（canvas，video，webstorage，语义化标签，表单控件  等）    !
 
18.HTTP请求返回状态码（至少说出常见的200,304,404）!
 
19.关系型数据库和非关系型数据库的区别和好处  !!!
 
20.web网络请求的过程 !!!     -->
 

<!-- 1. 一个需求一个分支进行开发的时候，一个新的紧急需求加入进来，当前编辑的需求不想提交，如何进行下一个分支的编辑又不会造成污染？

2. React性能优化
3. 如何看待react？
4. Git命令
5. 如何做一个项目？
 
6、js常用语东西，promise,跨域，数组。react问的也不深
7、生命周期钩子和他们的作用
8、闭包，变量提升
9、es6新增
  -->
