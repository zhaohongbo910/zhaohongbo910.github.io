---
title: Bolb对象
date: 2019-01-01
tags:
 - JavaScript 
 - Bolb       
categories: 
 - 前端
---

## Blod 对象穿件下载
+ blob Blob对象是包含有只读原始数据的类文件对象,存储着大量的二进制数据，并且 blob 的 size 和 type 属性，都会被 file 对象所继承。
```js     
function createDownloadFile(bufferData,downloadName) {
    var blob = new Blob([bufferData],{type:"application/对应文件的MIME类型;charset=UTF-8});
    let blobUrl = window.URL.createObjectURL(blob);
    const aElement = document.createElement('a');
    document.body.appendChild(aElement);
    aElement.style.display = 'none';
    aElement.href = blobUrl;
    aElement.download = downloadName;
    aElement.click();
    document.body.removeChild(aElement);
    window.URL.revokeObjectURL(blobUrl);  // 下载完成进行释放
}
window.onload = createDownloadFile;
//  需要在请求的header 里设置 返回值类型	responseType: 'blob',
```
## Blob 转化成File读取二进制     

``` js
var file = new FileReader();
//把blob文件转化为arraybuffer；
file.readAsArrayBuffer(blob)
//读取完成以后load事件
file.addEventListener("load", function(ev) {
    var abb = ev.target.result;
    var iAA = new Int8Array(abb);
    console.log(iAA);
});
```   


## 通过构造函数
```js
var blob = new Blob(dataArr:Array<any>, opt:{type:string});
```
+ dataArray：数组，包含了要添加到Blob对象中的数据，数据可以是任意多个ArrayBuffer，ArrayBufferView， Blob，或者 DOMString对象。
+ opt：对象，用于设置Blob对象的属性（如：MIME类型）
+ 

###  1、创建一个装填DOMString对象的Blob对象
```js   
    var s = '<div>Hello word !</div>'
    var blob = new Blob([s],{type:'text/html'})
   
    // 输出结果
    Blob(23) {size: 23,type: "text/html"}
        size: 23       == s.length
        type: "text/html"
    __proto__: Blob
```
### 2、创建一个装填ArrayBuffer对象的Blob对象
```js
    var s1 = new ArrayBuffer(10)
    var blob1 = new Blob([s1],{type:'text/plain'})
```  
### 3、创建一个装填ArrayBufferView对象的Blob对象（ArrayBufferView可基于ArrayBuffer创建，返回值是一个类数组。
```js
    var s2 = new ArrayBuffer(10)
    var s3 = new Int16Array(s2)
    var blob1 = new Blob([s3],{type:'text/plain'})
```     
     
## 通过Blob.slice()
+ 此方法返回一个新的Blob对象，包含了原Blob对象中指定范围内的数据
```js
    Blob.slice(start:number, end:number, contentType:string)
```   
+ start：开始索引，默认为0
+ end：截取结束索引（不包括end）
+ contentType：新Blob的MIME类型，默认为空字符串   
```js
    var b  = new Blob(['zdsdsdfdfjkfjdfjldfljajldjfaljfldajldjfajjajdldfalsjdflja'],{type:'text/plain'})
    var b1 = b.slice(0,5,'text/plain')
```
## 通过canvas.toBlob()
```js
    var canvas = document.getElementById("canvas");
    canvas.toBlob(function(blob){
        console.log(blob);
    });
```    
    
    
## 分片上传
+ 通过Blob.slice方法，可以将大文件分片，轮循向后台提交各文件片段，即可实现文件的分片上传。
> 分片上传逻辑如下：

+ 获取要上传文件的File对象，根据chunk（每片大小）对文件进行分片
通过post方法轮循上传每片文件，其中url中拼接querystring用于描述当前上传的文件信息；post body中存放本次要上传的二进制数据片段
接口每次返回offset，用于执行下次上传
下面是分片上传的简单实现：
```js

    initUpload();
    //初始化上传
    function initUpload() {
        var chunk = 100 * 1024;   //每片大小
        var input = document.getElementById("file");    //input file
        input.onchange = function (e) {
            var file = this.files[0];
            var query = {};
            var chunks = [];
            if (!!file) {
                var start = 0;
                //文件分片
                for (var i = 0; i < Math.ceil(file.size / chunk); i++) {
                    var end = start + chunk;
                    chunks[i] = file.slice(start , end);
                    start = end;
                }
                
                // 采用post方法上传文件
                // url query上拼接以下参数，用于记录上传偏移
                // post body中存放本次要上传的二进制数据
                query = {
                    fileSize: file.size,
                    dataSize: chunk,
                    nextOffset: 0
                }

                upload(chunks, query, successPerUpload);
            }
        }
    }


    // 执行上传
    function upload(chunks, query, cb) {
        var queryStr = Object.getOwnPropertyNames(query).map(key => {
            return key + "=" + query[key];
        }).join("&");
        // 
        var xhr = new XMLHttpRequest();
        
        xhr.open("POST", "http://xxxx/opload?" + queryStr);
        // 
        xhr.overrideMimeType("application/octet-stream");
        
        //获取post body中二进制数据
        var index = Math.floor(query.nextOffset / query.dataSize);
        // 获取文件的二进制数据 
        getFileBinary(chunks[index], function (binary) {
            if (xhr.sendAsBinary) {
                xhr.sendAsBinary(binary);
            } else {
                xhr.send(binary);
            }

        });

        xhr.onreadystatechange = function (e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    var resp = JSON.parse(xhr.responseText);
                    // 接口返回nextoffset
                    // resp = {
                    //     isFinish:false,
                    //     offset:100*1024
                    // }
                    if (typeof cb === "function") {
                        cb.call(this, resp, chunks, query)
                    }
                }
            }
        }
    }

    // 每片上传成功后执行
    function successPerUpload(resp, chunks, query) {
        if (resp.isFinish === true) {
            alert("上传成功");
        } else {
            //未上传完毕
            query.offset = resp.offset;
            upload(chunks, query, successPerUpload);
        }
    }

    // 获取文件二进制数据
    function getFileBinary(file, cb) {
        var reader = new FileReader();
        reader.readAsArrayBuffer(file);
        reader.onload = function (e) {
            if (typeof cb === "function") {
                cb.call(this, this.result);
            }
        }
    }
```